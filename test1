import quickfix as fix
import time
import datetime
import os

class MyApplication(fix.Application):
    def __init__(self):
        super().__init__()
        self.sessions = {}
        self.log_directory = "log"
        self.message_buffer = {}  # Dictionary to store messages batched by session

    def onCreate(self, sessionID):
        print("Session created -", sessionID.toString())
        self.sessions[sessionID] = fix.Session.lookupSession(sessionID)

    def fromApp(self, message, sessionID):
        # Add the incoming message to the message buffer for the corresponding session
        if sessionID not in self.message_buffer:
            self.message_buffer[sessionID] = []
        self.message_buffer[sessionID].append(message)

    def toApp(self, message, sessionID):
        pass

    def fromAdmin(self, message, sessionID):
        msg_type = message.getHeader().getField(fix.MsgType()).getString()
        if msg_type == fix.MsgType_Logout:
            reason = message.getField(58)  # Extract the logout reason
            print(f"Received Logout: {reason}")
            # Log the logout reason
            log_file_path = self.get_log_file()
            with open(log_file_path, "a") as log_file:
                log_file.write(f"Received Logout: {reason}\n")
        # Handle other administrative messages if needed

    def toAdmin(self, message, sessionID):
        if message.getHeader().getField(fix.MsgType()).getString() == fix.MsgType_Logon:
            message.getHeader().setField(1408, "1.3")
            message.getHeader().setField(43, "Y")
            print("sent admin message", message.toString())
        return True

    def onLogout(self, sessionID):
        print("Logout initiated -", sessionID.toString())
        # Log the logout event
        log_file_path = self.get_log_file()
        with open(log_file_path, "a") as log_file:
            log_file.write(f"Logout initiated - {sessionID.toString()}\n")

    def onLogon(self, sessionID):
        print("Logon Successful -", sessionID.toString())

    def process_batch(self, sessionID):
        # Process the collected messages as a batch
        print(f"Processing {len(self.message_buffer[sessionID])} messages in batch for session {sessionID}")
        log_file_path = self.get_log_file()  # Get log file path

        with open(log_file_path, "a") as log_file:
            for message in self.message_buffer[sessionID]:
                msg_type = message.getHeader().getField(fix.MsgType()).getString()
                if msg_type != fix.MsgType_Heartbeat:  # Check if message type is not heartbeat
                    log_file.write(f"Received FIX Message: {message.toString()}\n")
                    print(f"Received FIX Message: {message.toString()}")
        
        # Clear the message buffer after processing
        self.message_buffer[sessionID].clear()

    def get_log_file(self):
        log_directory = "log"
        os.makedirs(log_directory, exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H")
        log_file_name = f"log_file_{timestamp}.log"
        return os.path.join(self.log_directory, log_file_name)

    def run(self):
        settings = fix.SessionSettings(self.connection_config_file)
        application = fix.SocketInitiator(self, fix.FileStoreFactory(settings), settings)
        application.start()

        time.sleep(1)

        application.stop()


app = MyApplication()
app.connection_config_file = "acceptor.cfg"

# Run the FIX application
app.run()
