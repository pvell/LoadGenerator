def send_and_receive(self, message_type, message):
        # Send the message over the TCP connection
        send_message(self.client_socket, message)

        # Initialize a buffer to store received data
        receive_buffer = b""
        print(receive_buffer)

        while True:
            # Receive data from the socket
            try:
                received_data = self.client_socket.recv(4096)
            except ConnectionResetError:
                print("Connection reset by peer")
                pass

            if not received_data:
                # If no more data is received, exit the loop
                break

            # Initialize a buffer to store received data
            receive_buffer += received_data
            print('receive buffer: ',receive_buffer)



            while len(receive_buffer) >= 3:  # At least 3 bytes are needed for header
                # Extract header information
                message_type = receive_buffer[0]
                message_length = int.from_bytes(receive_buffer[1:3], byteorder='big')
                
                print('header_bytes:', receive_buffer[1:3])
                print('message_type:', message_type)
                print('message_length:', message_length)

                if message_type == 0:  # Heartbeat message
                    # Skip heartbeat message and update receive_buffer
                    receive_buffer = receive_buffer[3:]
                elif len(receive_buffer) >= 3 + message_length:  # Full message received
                    # Extract the complete_message without the header
                    complete_message = receive_buffer[3:3 + message_length]

                    # Process and parse the complete_message as needed

                    # Update receive_buffer to remove processed bytes
                    receive_buffer = receive_buffer[3 + message_length:]
                else:
                    # Incomplete message, wait for more data to arrive
                    break

        return receive_buffer
