 worker_20 • Python • 4.0 GB • dh-query-mde-1.memxtrading.com  • 
Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
tables
Python command, "tables" failed:
from deephaven import jpy
TRADE_DATE = "2021-11-01"
MIN_NOTIONAL = 5000
MIN_VOLUME = 99
WASH_TIME_DIFF_SECONDS = 10
EXCHANGE_CODE = "U"
WASH_TIME_NANOS = str(WASH_TIME_DIFF_SECONDS * 1000000000)
SimpleDateFormat = jpy.get_type("java.text.SimpleDateFormat")
sdf = SimpleDateFormat("yyyy-MM-dd");
stf = SimpleDateFormat("HH:mm:ss");
MIDS_Partitions = db.t("MIDS", "Common").selectDistinct("DeephavenPartitionID").tail(5).updateView("Date=sdf.format(nanosToTime(Long.parseLong(DeephavenPartitionID.split(`_`)[1]) * SECOND).getDate())");
TargetDatePartition = MIDS_Partitions.where("Date = TRADE_DATE");
#Get Clearing Records
ClearingRecords = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 701 && Exchange = '" + EXCHANGE_CODE +  "' && BuyerMPID == SellerMPID && ExecutedQuantity >= MIN_VOLUME && (ExecutionPrice/1000000)*ExecutedQuantity >= MIN_NOTIONAL").select("BuyerExchangeOrderId","SellerExchangeOrderId", "BuyerMPID", "SellerMPID","BuyerOrderCapacity","SellerOrderCapacity","ExecutedQuantity","ExecutionPrice = ExecutionPrice/1000000","ExecutionTimestamp","NasdaqSymbol","MatchId");
#Get FirmAccount
AccountInfo = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 110").select("AccountId","Name","FirmId","MPID")
FirmInfo = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 111").select("FirmId","InstitionName","FirmName","CRDNumber");
AccountFirmInfo = AccountInfo.naturalJoin(FirmInfo, "FirmId","InstitionName, FirmName, CRDNumber")
#Add Order Times for Buy/Sell
Orders = db.t("MIDS","Order").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 420")
ClearingRecords = ClearingRecords.naturalJoin(Orders, "BuyerExchangeOrderId = ExchangeOrderId, NasdaqSymbol = SymbolId", "BuyerEventTime = CausedAtEventTimestamp").naturalJoin(Orders, "SellerExchangeOrderId = ExchangeOrderId, NasdaqSymbol = SymbolId", "SellerEventTime = CausedAtEventTimestamp")
#Add AccountId from Trade event for Buy/Sell
Trades = db.t("MIDS","Order").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 426").select("ExchangeOrderId", "MatchId", "AccountId")
ClearingRecords = ClearingRecords.naturalJoin(Trades, "BuyerExchangeOrderId = ExchangeOrderId, MatchId = MatchId", "BuyerAccountId = AccountId").naturalJoin(Trades, "SellerExchangeOrderId = ExchangeOrderId, MatchId = MatchId", "SellerAccountId = AccountId")
#Join FirmAccount on AccountId for Buy/Sell
ClearingRecords = ClearingRecords.naturalJoin(AccountFirmInfo, "BuyerAccountId = AccountId", "BuyerFirmId = FirmId, BuyerFirmName = InstitionName").naturalJoin(AccountFirmInfo, "SellerAccountId = AccountId", "SellerFirmId = FirmId, SellerFirmName = InstitionName")
#Filter where Firm_Name + Account Id == Firm_Name + Account Id && Where order times are within 10 seconds
Wash_Trades = ClearingRecords.where("BuyerAccountId = SellerAccountId && BuyerFirmId = SellerFirmId").where("BuyerEventTime - SellerEventTime <= Long.parseLong(WASH_TIME_NANOS)").where("SellerEventTime - BuyerEventTime <= Long.parseLong(WASH_TIME_NANOS)")
Wash_Trades = Wash_Trades.updateView("Date = sdf.format(nanosToTime(ExecutionTimestamp).getDate())", "Time =stf.format(nanosToTime(ExecutionTimestamp).getDate())","Notional = ExecutedQuantity*ExecutionPrice").dropColumns("ExecutionTimestamp").formatColumns("ExecutionPrice=Decimal(`$###,##0.00#`)").formatColumns("Notional=Decimal(`$###,##0.00#`)")
#figure out why extra records #should I have to do this?
Wash_Trades = Wash_Trades.dropColumns("MatchId").selectDistinct()
Wash_Trades = Wash_Trades.dropColumns("BuyerExchangeOrderId","SellerExchangeOrderId","SellerMPID","BuyerEventTime","SellerEventTime","SellerAccountId","SellerFirmId","SellerFirmName")
Wash_Trades = Wash_Trades.renameColumns("MPID = BuyerMPID","Quantity = ExecutedQuantity","Security = NasdaqSymbol", "Account_Id = BuyerAccountId", "Firm_Id = BuyerFirmId", "Firm_Name = BuyerFirmName")
#handle scenarios and capacities
def get_scenario(x, y):
    if(x == 1 and y == 1):
        return 3
    elif(x == 2 and  y == 2):
      return 1
    else:
        return 2
def get_order_capacity_string(x):
    if(x == 1):
        return "Agency"
    elif(x == 2):
      return "Principal"
    elif(x == 3):
        return "RisklessPrincipal"
    else:
        return "Unknown"
Wash_Trades = Wash_Trades.updateView("Scenario = (int)get_scenario.call(BuyerOrderCapacity, SellerOrderCapacity)")
Wash_Trades = Wash_Trades.updateView("BuyerOrderCapacity = (String)get_order_capacity_string.call(BuyerOrderCapacity)", "SellerOrderCapacity = (String)get_order_capacity_string.call(SellerOrderCapacity)")
#reorder columns
Wash_Trades = Wash_Trades.moveUpColumns("Date", "Time", "Security", "Quantity","ExecutionPrice","Notional","Firm_Name","Firm_Id","MPID","Account_Id","BuyerOrderCapacity","SellerOrderCapacity","Scenario")
#sort
Wash_Trades = Wash_Trades.sort("Time")
Python command, "from deephaven import jpy
TRADE_DATE = "2021-11-01"
MIN_NOTIONAL = 5000
MIN_VOLUME = 99
WASH_TIME_DIFF_SECONDS = 10
EXCHANGE_CODE = "U"
WASH_TIME_NANOS = str(WASH_TIME_DIFF_SECONDS * 1000000000)
SimpleDateFormat = jpy.get_type("java.text.SimpleDateFormat")
sdf = SimpleDateFormat("yyyy-MM-dd");
stf = SimpleDateFormat("HH:mm:ss");
MIDS_Partitions = db.t("MIDS", "Common").selectDistinct("DeephavenPartitionID").tail(5).updateView("Date=sdf.format(nanosToTime(Long.parseLong(DeephavenPartitionID.split(`_`)[1]) * SECOND).getDate())");
TargetDatePartition = MIDS_Partitions.where("Date = TRADE_DATE");
#Get Clearing Records
ClearingRecords = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 701 && Exchange = '" + EXCHANGE_CODE +  "' && BuyerMPID == SellerMPID && ExecutedQuantity >= MIN_VOLUME && (ExecutionPrice/1000000)*ExecutedQuantity >= MIN_NOTIONAL").select("BuyerExchangeOrderId","SellerExchangeOrderId", "BuyerMPID", "SellerMPID","BuyerOrderCapacity","SellerOrderCapacity","ExecutedQuantity","ExecutionPrice = ExecutionPrice/1000000","ExecutionTimestamp","NasdaqSymbol","MatchId");
#Get FirmAccount
AccountInfo = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 110").select("AccountId","Name","FirmId","MPID")
FirmInfo = db.t("MIDS","Common").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 111").select("FirmId","InstitionName","FirmName","CRDNumber");
AccountFirmInfo = AccountInfo.naturalJoin(FirmInfo, "FirmId","InstitionName, FirmName, CRDNumber")
#Add Order Times for Buy/Sell
Orders = db.t("MIDS","Order").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 420")
ClearingRecords = ClearingRecords.naturalJoin(Orders, "BuyerExchangeOrderId = ExchangeOrderId, NasdaqSymbol = SymbolId", "BuyerEventTime = CausedAtEventTimestamp").naturalJoin(Orders, "SellerExchangeOrderId = ExchangeOrderId, NasdaqSymbol = SymbolId", "SellerEventTime = CausedAtEventTimestamp")
#Add AccountId from Trade event for Buy/Sell
Trades = db.t("MIDS","Order").whereIn(TargetDatePartition, "DeephavenPartitionID").where("MessageId = 426").select("ExchangeOrderId", "MatchId", "AccountId")
ClearingRecords = ClearingRecords.naturalJoin(Trades, "BuyerExchangeOrderId = ExchangeOrderId, MatchId = MatchId", "BuyerAccountId = AccountId").naturalJoin(Trades, "SellerExchangeOrderId = ExchangeOrderId, MatchId = MatchId", "SellerAccountId = AccountId")
#Join FirmAccount on AccountId for Buy/Sell
ClearingRecords = ClearingRecords.naturalJoin(AccountFirmInfo, "BuyerAccountId = AccountId", "BuyerFirmId = FirmId, BuyerFirmName = InstitionName").naturalJoin(AccountFirmInfo, "SellerAccountId = AccountId", "SellerFirmId = FirmId, SellerFirmName = InstitionName")
#Filter where Firm_Name + Account Id == Firm_Name + Account Id && Where order times are within 10 seconds
Wash_Trades = ClearingRecords.where("BuyerAccountId = SellerAccountId && BuyerFirmId = SellerFirmId").where("BuyerEventTime - SellerEventTime <= Long.parseLong(WASH_TIME_NANOS)").where("SellerEventTime - BuyerEventTime <= Long.parseLong(WASH_TIME_NANOS)")
Wash_Trades = Wash_Trades.updateView("Date = sdf.format(nanosToTime(ExecutionTimestamp).getDate())", "Time =stf.format(nanosToTime(ExecutionTimestamp).getDate())","Notional = ExecutedQuantity*ExecutionPrice").dropColumns("ExecutionTimestamp").formatColumns("ExecutionPrice=Decimal(`$###,##0.00#`)").formatColumns("Notional=Decimal(`$###,##0.00#`)")
#figure out why extra records #should I have to do this?
Wash_Trades = Wash_Trades.dropColumns("MatchId").selectDistinct()
Wash_Trades = Wash_Trades.dropColumns("BuyerExchangeOrderId","SellerExchangeOrderId","SellerMPID","BuyerEventTime","SellerEventTime","SellerAccountId","SellerFirmId","SellerFirmName")
Wash_Trades = Wash_Trades.renameColumns("MPID = BuyerMPID","Quantity = ExecutedQuantity","Security = NasdaqSymbol", "Account_Id = BuyerAccountId", "Firm_Id = BuyerFirmId", "Firm_Name = BuyerFirmName")
#handle scenarios and capacities
def get_scenario(x, y):
    if(x == 1 and y == 1):
        return 3
    elif(x == 2 and  y == 2):
      return 1
    else:
        return 2
def get_order_capacity_string(x):
    if(x == 1):
        return "Agency"
    elif(x == 2):
      return "Principal"
    elif(x == 3):
        return "RisklessPrincipal"
    else:
        return "Unknown"
Wash_Trades = Wash_Trades.updateView("Scenario = (int)get_scenario.call(BuyerOrderCapacity, SellerOrderCapacity)")
Wash_Trades = Wash_Trades.updateView("BuyerOrderCapacity = (String)get_order_capacity_string.call(BuyerOrderCapacity)", "SellerOrderCapacity = (String)get_order_capacity_string.call(SellerOrderCapacity)")
#reorder columns
Wash_Trades = Wash_Trades.moveUpColumns("Date", "Time", "Security", "Quantity","ExecutionPrice","Notional","Firm_Name","Firm_Id","MPID","Account_Id","BuyerOrderCapacity","SellerOrderCapacity","Scenario")
#sort
Wash_Trades = Wash_Trades.sort("Time")" failed:

java.lang.RuntimeException: Error in Python interpreter:
Type: <class 'RuntimeError'>
Value: java.lang.IllegalArgumentException: A non-null, non-empty list of keys to match must be provided
	at com.illumon.iris.db.v2.dataindex.AbstractGroupingBuilder.matching(AbstractGroupingBuilder.java:105)
	at com.illumon.iris.db.v2.sources.AbstractColumnSource.match(AbstractColumnSource.java:154)
	at com.illumon.iris.db.v2.select.DynamicWhereFilter.filter(DynamicWhereFilter.java:206)
	at com.illumon.iris.db.v2.AbstractFilterExecution.doFilter(AbstractFilterExecution.java:136)
	at com.illumon.iris.db.v2.AbstractFilterExecution.scheduleCompletion(AbstractFilterExecution.java:247)
	at com.illumon.iris.db.v2.QueryTable.lambda$where$47(QueryTable.java:1121)
	at com.illumon.iris.db.v2.BaseTable.initializeWithSnapshot(BaseTable.java:1436)
	at com.illumon.iris.db.v2.QueryTable.lambda$where$48(QueryTable.java:1109)
	at com.illumon.iris.db.v2.QueryTable.memoizeResult(QueryTable.java:2927)
	at com.illumon.iris.db.v2.QueryTable.lambda$where$49(QueryTable.java:1105)
	at com.illumon.iris.db.tables.utils.QueryPerformanceRecorder.withNugget(QueryPerformanceRecorder.java:507)
	at com.illumon.iris.db.v2.QueryTable.where(QueryTable.java:1062)
	at com.illumon.iris.db.v2.QueryTable.lambda$whereIn$50(QueryTable.java:1215)
	at com.illumon.iris.db.tables.utils.QueryPerformanceRecorder.withNugget(QueryPerformanceRecorder.java:507)
	at com.illumon.iris.db.v2.QueryTable.whereIn(QueryTable.java:1203)
	at com.illumon.iris.db.v2.UncoalescedTable.whereIn(UncoalescedTable.java:174)
	at com.illumon.iris.db.tables.Table.whereIn(Table.java:431)
	at org.jpy.PyLib.executeCode(Native Method)
	at org.jpy.PyObject.executeCode(PyObject.java:138)
	at com.illumon.iris.db.util.PythonEvaluatorJpy.evalScript(PythonEvaluatorJpy.java:53)
	at com.illumon.iris.db.util.IrisDbPythonSession.lambda$evaluate$1(IrisDbPythonSession.java:147)
	at com.illumon.util.locks.FunctionalLock.doLockedInterruptibly(FunctionalLock.java:45)
	at com.illumon.iris.db.util.IrisDbPythonSession.evaluate(IrisDbPythonSession.java:146)
	at com.illumon.iris.console.events.RemoteScriptCommandQuery.execute(RemoteScriptCommandQuery.java:92)
	at com.illumon.iris.console.events.RemoteScriptCommandQuery.execute(RemoteScriptCommandQuery.java:25)
	at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$QueryAction.lambda$execute$0(RemoteQueryProcessor.java:1920)
	at com.illumon.util.locks.FunctionalLock.computeLockedInterruptibly(FunctionalLock.java:97)
	at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$QueryAction.execute(RemoteQueryProcessor.java:1920)
	at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler.runSyncQueryAndSendResult(RemoteQueryProcessor.java:1682)
	at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler.handleCommandST(RemoteQueryProcessor.java:1576)
	at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler$HandleCommandRunnable.run(RemoteQueryProcessor.java:1171)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.lang.Thread.run(Thread.java:891)

Line: 14
Namespace: <module>
File: <string>
Traceback (most recent call last):
  File "<string>", line 14, in <module>

        at org.jpy.PyLib.executeCode(PyLib.java:-2)
        at org.jpy.PyObject.executeCode(PyObject.java:138)
        at com.illumon.iris.db.util.PythonEvaluatorJpy.evalScript(PythonEvaluatorJpy.java:53)
        at com.illumon.iris.db.util.IrisDbPythonSession.lambda$evaluate$1(IrisDbPythonSession.java:147)
        at com.illumon.util.locks.FunctionalLock.doLockedInterruptibly(FunctionalLock.java:45)
        at com.illumon.iris.db.util.IrisDbPythonSession.evaluate(IrisDbPythonSession.java:146)
        at com.illumon.iris.console.events.RemoteScriptCommandQuery.execute(RemoteScriptCommandQuery.java:92)
        at com.illumon.iris.console.events.RemoteScriptCommandQuery.execute(RemoteScriptCommandQuery.java:25)
        at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$QueryAction.lambda$execute$0(RemoteQueryProcessor.java:1920)
        at com.illumon.util.locks.FunctionalLock.computeLockedInterruptibly(FunctionalLock.java:97)
        at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$QueryAction.execute(RemoteQueryProcessor.java:1920)
        at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler.runSyncQueryAndSendResult(RemoteQueryProcessor.java:1682)
        at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler.handleCommandST(RemoteQueryProcessor.java:1576)
        at com.illumon.iris.db.tables.remotequery.RemoteQueryProcessor$ClientConnectionHandler$HandleCommandRunnable.run(RemoteQueryProcessor.java:1171)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
        at java.util.concurrent.FutureTask.run(FutureTask.java:264)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
        at java.lang.Thread.run(Thread.java:891)

Python Command History



