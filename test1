import unittest
import socket
import struct
import time
from sbe_encoder_decoder_new import *
from sbe_message_types import *
from sbe_messages2 import sbe_messages
from decode_ER import *
from get_config import *


# Function to establish SBE TCP session
def establish_session(session_name):
    # Get connection details for the specified session name
    host = connection_config[session_name]['host']
    port = int(connection_config[session_name]['port'])
    user = connection_config[session_name]['user']
    password = connection_config[session_name]['password']
    token = f'{user}:{password}'
    # Login request
    message_type = 100
    token_type = 'P'  # Assuming token type is always 'P'
    token_length = len(token)
    header = struct.pack('!BHB', message_type, token_length + 1, token_type.encode('utf-8')[0])
    message = header + token.encode('utf-8')

    # Create a socket and establish the connection
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))

    # Set socket to binary mode
    client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

    # Send the login request
    client_socket.sendall(message)

    # Receive and handle the response
    response_header = client_socket.recv(3)
    
    response_type, response_length = struct.unpack('!B H', response_header)

    if response_type == 1:  # Login Accepted
        response_message = client_socket.recv(response_length)
        print("Login Accepted:", response_message.decode('utf-8'))
        session_id = None
    elif response_type == 2:  # Login Rejected
        response_message = client_socket.recv(response_length)
        print("Login Rejected:", response_message.decode('utf-8'))
        client_socket.close()
        exit()  # Exit the script gracefully after login rejection
    else:
        print("Invalid response received.")
        client_socket.close()
        exit()  # Exit the script if an invalid response is received

    # Continue with the session
    while True:
        response_header = client_socket.recv(11)
        response_type, response_length, session_id = struct.unpack('!B H Q', response_header)

        if response_type == 3:  # Start of Session
            print("Start of Session. Session ID:", session_id)
            break
        else:
            print("Invalid response received.")

    # Stream Request
    stream_request_type = 103
    stream_request_length = 16  # 4 bytes for message type and length, 8 bytes for session ID, 8 bytes for next sequence number
    NEXT_SEQUENCE_NUMBER = 0
    stream_request_header = struct.pack('!BHQQ', stream_request_type, stream_request_length, session_id, NEXT_SEQUENCE_NUMBER)
    stream_request = stream_request_header

    # Send the Stream Request
    client_socket.sendall(stream_request)

    response_header = client_socket.recv(3)
    response_type, response_length = struct.unpack('!B H', response_header)

    if response_type == 9:  # Stream Rejected
        response_message = client_socket.recv(response_length)
        reject_code = response_message.decode('utf-8')
        print("Stream Rejected. Reject Code:", reject_code)
        client_socket.close()
        exit()
    elif response_type == 10:  # End of Stream
        response_message = client_socket.recv(response_length)
        print("End of Stream")
        client_socket.close()
        exit()
    elif response_type == 8:  # Stream Begin
        response_message = client_socket.recv(response_length - 2)
        NEXT_SEQUENCE_NUMBER  = struct.unpack('!Q', response_message[3:11])
        print("Stream Begin received")
    else:
        print("Invalid Message received")

    return client_socket, session_id



# Send the generated message over the TCP connection
def send_message(client_socket, message):
    # Send the message
    client_socket.sendall(message)
    # Sleep for a short period to control the message rate
    #time.sleep(1 / message_rate)
    time.sleep(1)


              
class SBETestCase(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Establish the session before running any test cases
        cls.client_socket, cls.session_id = establish_session('Session1')

    @classmethod
    def tearDownClass(cls):
        # Close the session after all test cases have been executed
        cls.client_socket.close()
    def handle_sbe_message(self, message_data, message_type):
        # Extract the SBE header and determine template ID
        sbe_header = message_data[:8]
        #block_length, template_id, schema_id, version, num_groups = struct.unpack('!HBBHb', sbe_header)
        template_id = struct.unpack_from('!B', sbe_header, 7)[0]
        print('template_id:',template_id)
        
        # Determine the message type based on TemplateID
        message_type = None
        for msg_type, template_id_val in MESSAGE_TYPES.items():
            if template_id_val == template_id:
                message_type = msg_type
                break
        if message_type is not None:
            print(f"Decoded Message Type: {message_type}")   
        
        decoded_message = {}
        # if message_type is not None:
        #     # Call the decode function based on message_type
        #     #decode_message(message_data[7:], message_type)
        #     decoded_message = decode_ER_BulkQuote_ComponentNew(message_data[7:])
        if template_id == 11:
            decoded_message = decode_ER_New(message_data[8:])
        elif template_id == 12:
            decoded_message = decode_BulkQuote_pending_new(message_data[8:])
        elif template_id == 13:
            decoded_message = decode_ER_BulkQuote_ComponentNew(message_data[8:])
        elif template_id == 14:
            decoded_message = decode_ER_Rejected(message_data[8:])
        return decoded_message
    
    def send_and_receive(self, message_type, message):
        # Send the message over the TCP connection
        send_message(self.client_socket, message)

        # Initialize a buffer to store received data
        receive_buffer = b""

        while True:
            # Receive data from the socket
            try:
                received_data = self.client_socket.recv(4096)
            except ConnectionResetError:
                pass
            
            if not received_data:
                # If no more data is received, exit the loop
                break

            # Add the received data to the receive buffer
            receive_buffer += received_data
            print('receive buffer: ',receive_buffer)
            
            # Process messages in the receive buffer
            while True:
            #while len(receive_buffer) >7:
                # Read the header to determine message length (3 bytes)
                if len(receive_buffer) < 3:
                    break
                print('len(receive_buffer):',len(receive_buffer))
                
                # Unpack the header
                message_length = struct.unpack('!H', receive_buffer[1:3])[0]
                print('message length:',message_length)
                # if len(receive_buffer) < 3 + message_length:
                #     # If the full message is not yet in the buffer, exit the loop
                #     break
                
                # Extract the complete message
                complete_message = receive_buffer[:3 + message_length]
                print('complete message: ',complete_message)
                # Update the receive buffer
                receive_buffer = receive_buffer[3 + message_length:]
                
                # Process the complete message
                self.handle_sbe_message(complete_message, message_type)

    
    

    # def send_and_receive(self, message_type, message):
    #     # Send the message over the TCP connection
    #     send_message(self.client_socket, message)
        
    #     # Receive the first 10 bytes of the response message
    #     response_header = self.client_socket.recv(10)
        
    #     print('Resonse header=======',response_header)
                    
    #     # Decode the template ID from the 5th byte
    #     template_id = struct.unpack_from('!B', response_header, 7)[0]
    #     print('Temp id:',template_id)
    #     # Assuming response_length is calculated properly, receive the remaining response
    #     response_length = struct.unpack_from('!H', response_header, 1)[0]
    #     remaining_bytes = response_length - 10
        
    #     response_message = response_header + self.client_socket.recv(remaining_bytes)
        
    #     print('response meassage==',response_message)
        
    #     # Decode the message type based on the template ID
    #     decoded_message_type = None
    #     for message_name, message_template_id in MESSAGE_TYPES.items():
    #         if message_template_id == template_id:
    #             decoded_message_type = message_name
    #             break

    #     if decoded_message_type is not None:
    #         print(f"Decoded Message Type: {decoded_message_type}")        
        
    #     #template_id = struct.unpack('!B', response_message[2:3])[0]
    #     decoded_message ={}
    #     if template_id == 11:
    #         decoded_message = decode_ER_New(response_message[3:])
    #     elif template_id == 12:
    #         decoded_message = decode_BulkQuote_pending_new(response_message[3:])
    #     elif template_id == 13:
    #         decoded_message = decode_ER_BulkQuote_ComponentNew(response_message[3:])
    #     elif template_id == 14:
    #         decoded_message = decode_ER_Rejected(response_message[3:])
    #     elif template_id == 15:
    #         decoded_message = decode_ER_Trade(response_message[3:])
    #     elif template_id == 16:
    #         decoded_message = decode_ER_PendingCancel(response_message[3:])
    #     elif template_id == 17:
    #         decoded_message = decode_ER_Canceled(response_message[3:])
    #     elif template_id == 18:
    #         decoded_message = decode_ER_PendingReplace(response_message[3:])
    #     elif template_id == 19:
    #         decoded_message = decode_ER_Replaced(response_message[3:])
    #     elif template_id == 20:
    #         decoded_message = decode_ER_TradeCorrection(response_message[3:])
    #     elif template_id == 21:
    #         decoded_message = decode_ER_TradeBreak(response_message[3:])
    #     elif template_id == 22:
    #         decoded_message = decode_ER_Restatement(response_message[3:])
    #     elif template_id == 23:
    #         decoded_message = decode_PendingMassCancel(response_message[3:])
    #     elif template_id == 24:
    #         decoded_message = decode_MassCancelReject(response_message[3:])
            
    #     elif template_id == 25:
    #         decoded_message = decode_MassCancelDone(response_message[3:])
    #     elif template_id == 26:
    #         decoded_message = decode_OrderCancelReject(response_message[3:])
    #     elif template_id == 27:
    #         decoded_message = decode_AllocationInstructionAck(response_message[3:])
    #     elif template_id == 28:
    #         decoded_message = decode_AllocationInstructionAlert(response_message[3:])
    #     elif template_id == 29:
    #         decoded_message = decode_UserNotification(response_message[3:])
    #     elif template_id == 30:
    #         decoded_message = decode_MassCancelClearLockoutReject(response_message[3:])
    #     elif template_id == 31:
    #         decoded_message = decode_MassCancelClearLockoutDone(response_message[3:])
    #     else:
    #         print('Invalid template Id!')
    #         return
    #     print('decoded_message==', decoded_message)

    #     return decoded_message


    # def test_new_order_single(self):
    #     message_type = 'NewOrderSingle'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message(message_type, 'Session1')
    #     # Send and receive the message
    #     dm = self.send_and_receive(message_type, message)
        
    #     #order cancel request
    #     message_type2 = 'OrderCancelRequest'
    #     message2 = sbe_messages.generate_message2(message_type2, 'Session1', dm)
    #     #self.client_socket.sendall(message2)
    #     self.send_and_receive(message_type2, message2)

        

    def test_short_two_sided_bulk_quote(self):
        message_type = 'ShortTwoSidedBulkQuote'
        # Generate a message based on the message_type
        message = sbe_messages.generate_message(message_type, 'Session1')

        # Send and receive the message
        self.send_and_receive(message_type, message)
        
    # def test_long_two_sided_bulk_quote(self):
    #     message_type = 'LongTwoSidedBulkQuote'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message(message_type, 'Session1')        
    #     # Send and receive the message
    #     self.send_and_receive(message_type, message)

    # def test_short_one_sided_bulk_quote(self):
    #     message_type = 'ShortOneSidedBulkQuote'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message(message_type, 'Session1')
    #     # Send and receive the message
    #     self.send_and_receive(message_type, message)

    # def test_long_one_sided_bulk_quote(self):
    #     message_type = 'LongOneSidedBulkQuote'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message(message_type, 'Session1')
    #     # Send and receive the message
    #     self.send_and_receive(message_type, message)

    # def test_order_cancel_request(self):
    #     message_type = 'OrderCancelRequest'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message(message_type, 'Session1')
    #     # Send and receive the message
    #     self.send_and_receive(message_type, message)

    # def test_mass_cancel_request(self):
    #     message_type = 'MassCancelRequest'
    #     # Generate a message based on the message_type
    #     message = sbe_messages.generate_message2(message_type, 'Session1', dm=None)
    #     # Send and receive the message
    #     self.client_socket.sendall(message)
    #     self.send_and_receive(message_type, message)
        
    # def test_allocation_instruction(self):
    #     message_type = 'AllocationInstruction'
    #     message = sbe_messages.generate_message3(message_type)
    #     print('Encoded message:\n',message)
    #     self.send_and_receive(message_type, message)
        


if __name__ == '__main__':
    unittest.main()
