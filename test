class MyApplication(fix.Application):

Capturing ClordId's

# ... (Existing code)

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True
                
                # Extract ClOrdID and OrdID from the execution report
                clordid = cl_ord_id.getString()
                ordid = exec_report.getField(fix.OrderID()).getString()

                # Write ClOrdID and OrdID to the text file
                self.write_clordid_ordid_to_file(clordid, ordid)


Adding order cancels:

class MyApplication(fix.Application):
    def __init__(self, message_weights, message_rate):
        # Existing code...
        self.captured_clordids = []  # Initialize an empty list to store the captured ClOrdIDs



class MyApplication(fix.Application):
    # Existing code...

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True
                
                # Extract ClOrdID and OrdID from the execution report
                clordid = cl_ord_id.getString()
                ordid = exec_report.getField(fix.OrderID()).getString()

                # Write ClOrdID and OrdID to the text file
                self.write_clordid_ordid_to_file(clordid, ordid)

                # Store the captured ClOrdID in the list
                self.captured_clordids.append(clordid)




class MyApplication(fix.Application):
    # Existing code...

    def send_order_cancel_request(self, orig_cl_ord_id):
        if not self.captured_clordids:
            print("No captured ClOrdIDs to generate order cancel.")
            return

        # Select a random ClOrdID from the list of captured ClOrdIDs
        selected_clordid = random.choice(self.captured_clordids)

        # Create the OrderCancelRequest message
        message = fix.Message()
        # Set the required fields for OrderCancelRequest
        # For example:
        message.getHeader().setField(fix.MsgType(fix.MsgType_OrderCancelRequest))
        message.setField(fix.ClOrdID(self.generate_clordid()))
        message.setField(fix.OrigClOrdID(selected_clordid))
        # Set other fields as required for the cancel request

        # Send the OrderCancelRequest message
        fix.Session.sendToTarget(message, self.session_id)




def create_session(self, session_settings):
    storeFactory = fix.FileStoreFactory(session_settings)
    logFactory = fix.FileLogFactory(session_settings)
    application = fix.SocketInitiator(self, storeFactory, session_settings, logFactory)
    application.start()
    return application

def run(self):
    settings = fix.SessionSettings(self.connection_config_file)

    for session_id in settings.sections():
        if session_id != "DEFAULT":
            session_settings = settings.get(session_id)
            application = self.create_session(session_settings)
            self.sessions[session_id] = application

    while not all(application.isLoggedOn() for application in self.sessions.values()):
        time.sleep(1)

    load = self.generate_load()

    start_time = time.time()
    message_count = 0

    while True:
        elapsed_time = time.time() - start_time

        if elapsed_time >= self.send_duration:
            break

        if message_count >= len(load):
            message_count = 0

        for session_id in self.sessions:
            application = self.sessions[session_id]

            if application is not None and application.isLoggedOn():
                message = self.generate_message(load[message_count], session_id)
                fix.Session.sendToTarget(message, session_id)
            message_count += 1

        time.sleep(1)

    for application in self.sessions.values():
        application.stop()



def run(self):
    settings = fix.SessionSettings(self.connection_config_file)

    for section in settings.getSections():
        session_settings = settings.get(session)
        application = fix.SocketInitiator(self, fix.FileStoreFactory(session_settings), session_settings)
        application.start()

    while not all(session.isLoggedOn() for session in self.sessions.values()):
        time.sleep(1)




