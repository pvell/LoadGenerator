import struct

class ER_NewDecoder:
    def __init__(self, encoded_message):
        self.encoded_message = encoded_message
        self.offset = 0

    def decode(self):
        # Decode SBE Header
        template_id, message_size = struct.unpack_from('>BB', self.encoded_message)
        self.offset += 2
        
        # Check if template_id is 11 (ER_New message type)
        if template_id != 11:
            raise ValueError("Incorrect message template ID")

        # Decode fields
        order_id, = struct.unpack_from('>Q', self.encoded_message, self.offset + 7)
        cl_ord_id = self.encoded_message[self.offset + 15: self.offset + 35].decode().strip('\x00')
        list_seq_no, = struct.unpack_from('>B', self.encoded_message, self.offset + 35)
        exec_id, = struct.unpack_from('>Q', self.encoded_message, self.offset + 36)
        ord_status, = struct.unpack_from('>B', self.encoded_message, self.offset + 44)
        options_security_id = self.encoded_message[self.offset + 45: self.offset + 53].decode().strip('\x00')
        side, = struct.unpack_from('>B', self.encoded_message, self.offset + 53)
        order_qty, = struct.unpack_from('>I', self.encoded_message, self.offset + 54)
        ord_type, = struct.unpack_from('>B', self.encoded_message, self.offset + 58)
        price_value, = struct.unpack_from('>Q', self.encoded_message, self.offset + 59)
        time_in_force, = struct.unpack_from('>B', self.encoded_message, self.offset + 67)
        open_or_close, = struct.unpack_from('>B', self.encoded_message, self.offset + 68)
        exec_inst, = struct.unpack_from('>H', self.encoded_message, self.offset + 69)
        trading_capacity, = struct.unpack_from('>B', self.encoded_message, self.offset + 71)
        reprice_frequency, = struct.unpack_from('>B', self.encoded_message, self.offset + 72)
        reprice_behavior, = struct.unpack_from('>B', self.encoded_message, self.offset + 73)
        leaves_qty, = struct.unpack_from('>I', self.encoded_message, self.offset + 74)
        cum_qty, = struct.unpack_from('>I', self.encoded_message, self.offset + 78)
        sending_time, = struct.unpack_from('>Q', self.encoded_message, self.offset + 82)
        transact_time, = struct.unpack_from('>Q', self.encoded_message, self.offset + 90)
        mtp_group_id, = struct.unpack_from('>H', self.encoded_message, self.offset + 98)
        match_trade_prevention, = struct.unpack_from('>B', self.encoded_message, self.offset + 100)
        cancel_group_id, = struct.unpack_from('>H', self.encoded_message, self.offset + 101)
        risk_group_id, = struct.unpack_from('>H', self.encoded_message, self.offset + 103)
        
        # Move offset to the start of Repeating Group Dimensions
        self.offset += 105

        # Extract NoPartyIDs from Repeating Group Dimensions
        no_party_ids, = struct.unpack_from('>H', self.encoded_message, self.offset)
        self.offset += 2

        # Move offset to the start of Parties Group
        self.offset += 2

        # Extract and decode the Parties Group
        parties = []
        for _ in range(no_party_ids):
            party_id = self.encoded_message[self.offset:self.offset+2].decode()
            party_id_source = self.encoded_message[self.offset+2:self.offset+3].decode()
            party_role, = struct.unpack_from('>B', self.encoded_message, self.offset+3)
            parties.append((party_id, party_id_source, party_role))
            self.offset += 4

        # Return the decoded fields
        return {
            "OrderID": order_id,
            "ClOrdID": cl_ord_id,
            "ListSeqNo": list_seq_no,
            "ExecID": exec_id,
            "OrdStatus": ord_status,
            "OptionsSecurityID": options_security_id,
            "Side": side,
            "OrderQty": order_qty,
            "OrdType": ord_type,
            "Price": price_value,
            "TimeInForce": time_in_force,
            "OpenOrClose": open_or_close,
            "ExecInst": exec_inst,
            "TradingCapacity": trading_capacity,
            "RepriceFrequency": reprice_frequency,
            "RepriceBehavior": reprice_behavior,
            "LeavesQty": leaves_qty,
            "CumQty": cum_qty,
            "SendingTime": sending_time,
            "TransactTime": transact_time,
            "MtpGroupID": mtp_group_id,
            "MatchTradePrevention": match_trade_prevention,
            "CancelGroupID": cancel_group_id,
            "RiskGroupID": risk_group_id,
            "Parties": parties
        }
