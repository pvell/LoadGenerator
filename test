import struct
import xml.etree.ElementTree as ET

def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()

    schema = {}

    for message in root.findall('message'):
        message_name = message.get('name')
        message_id = int(message.get('id'))
        fields = {}

        for field in message.findall('field'):
            field_name = field.get('name')
            field_id = int(field.get('id'))
            field_type = field.get('type')
            fields[field_name] = {'id': field_id, 'type': field_type}

        schema[message_name] = {'id': message_id, 'fields': fields}

    return schema

def encode_field(value, field_type):
    if field_type == 'char':
        return struct.pack('>c', value.encode('ascii'))
    elif field_type == 'UTCTimestampNanos':
        return struct.pack('>Q', value)
    elif field_type == 'string':
        encoded_value = value.encode('ascii')
        length = len(encoded_value)
        return struct.pack(f'>H{length}s', length, encoded_value)
    elif field_type == 'int8':
        return struct.pack('>b', value)
    elif field_type == 'int16':
        return struct.pack('>h', value)
    elif field_type == 'int32':
        return struct.pack('>i', value)
    elif field_type == 'int64':
        return struct.pack('>q', value)
    elif field_type == 'uint8':
        return struct.pack('>B', value)
    elif field_type == 'uint16':
        return struct.pack('>H', value)
    elif field_type == 'uint32':
        return struct.pack('>I', value)
    elif field_type == 'uint64':
        return struct.pack('>Q', value)
    elif field_type == 'float':
        return struct.pack('>f', value)
    elif field_type == 'double':
        return struct.pack('>d', value)
    else:
        raise ValueError(f"Unknown field type: {field_type}")

def encode_message(schema, message_name, field_values):
    message_id = schema[message_name]['id']
    fields = schema[message_name]['fields']

    encoded_fields = []
    for field_name, field_value in field_values.items():
        if field_name in fields:
            field_id = fields[field_name]['id']
            field_type = fields[field_name]['type']
            encoded_field = encode_field(field_value, field_type)
            encoded_fields.append(struct.pack('>H', field_id) + encoded_field)

    field_count = len(encoded_fields)
    encoded_message = struct.pack('>H', message_id) + struct.pack('>H', field_count) + b''.join(encoded_fields)

    return encoded_message

def decode_field(buffer, offset, field_type):
    if field_type == 'char':
        value = struct.unpack_from('>c', buffer, offset)[0].decode('ascii')
        return value, offset + 1
    elif field_type == 'UTCTimestampNanos':
        value = struct.unpack_from('>Q', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'string':
        length = struct.unpack_from('>H', buffer, offset)[0]
        offset += 2
        value = struct.unpack_from(f'>{length}s', buffer, offset)[0].decode('ascii')
        return value, offset + length
    else:
        raise ValueError(f"Unknown field type: {field_type}")

def decode_message(buffer, offset, schema):
    message_id = struct.unpack_from('>H', buffer, offset)[0]
    offset += 2

    # Find the message name based on the message ID
    message_name = None
    for name, message in schema.items():
        if message['id'] == message_id:
            message_name = name
            break

    if not message_name:
        raise ValueError(f"Unknown message ID: {message_id}")

    field_count = struct.unpack_from('>H', buffer, offset)[0]
    offset += 2

    decoded_fields = {}
    for _ in range(field_count):
        field_id = struct.unpack_from('>H', buffer, offset)[0]
        offset += 2

        # Find the field name and type based on the field ID and message name
        field_name = None
        field_type = None
        for name, field in schema[message_name]['fields'].items():
            if field['id'] == field_id:
                field_name = name
                field_type = field['type']
                break

        if not field_name:
            raise ValueError(f"Unknown field ID: {field_id} for message {message_name}")

        field_value, offset = decode_field(buffer, offset, field_type)
        decoded_fields[field_name] = field_value

    return message_name, decoded_fields

# Load the schema from the XML file
schema = load_schema('sbe-schema.xml')

# Sample field values for encoding
field_values = {
    'SendingTime': 1623341234000000000,
    'ClOrdID': 'ORD123',
    'OptionsSecurityID': 'OPT456',
    'Side': 1,
    'OrderQty': 100,
    'OrdType': 2,
    'Price': 10.5,
    'TimeInForce': 1,
    'OpenOrClose': 2,
    'ExecInst': 'XYZ',
    'TradingCapacity': 3,
    'RepriceFrequency': 4,
    'RepriceBehavior': 5,
    'MtpGroupID': 6,
    'MatchTradePrevention': 7,
    'CancelGroupID': 8,
    'RiskGroupID': 9,
    'Parties': [
        {'PartyID': 'P1', 'PartyIDSource': 'S1', 'PartyRole': 10},
        {'PartyID': 'P2', 'PartyIDSource': 'S2', 'PartyRole': 11}
    ]
}

# Encode the message
encoded_message = encode_message(schema, 'NewOrderSingle', field_values)
print(f"Encoded message: {encoded_message.hex()}")

# Decode the message
decoded_message_name, decoded_field_values = decode_message(encoded_message, 0, schema)
print(f"Decoded message name: {decoded_message_name}")
print(f"Decoded field values: {decoded_field_values}")






Traceback (most recent call last):
  File "/home/pvellanki/loadgenerator/sbe/test.py", line 30, in <module>
    schema = load_schema('sbe-schema.xml')
  File "/home/pvellanki/loadgenerator/sbe/test.py", line 6, in load_schema
    schema = XMLSchema(schema_file)
  File "/home/pvellanki/loadgenerator/myenv/lib/python3.10/site-packages/xmlschema/validators/schemas.py", line 463, in __init__
    self.parse_error(e.reason or e, elem=e.elem)
  File "/home/pvellanki/loadgenerator/myenv/lib/python3.10/site-packages/xmlschema/validators/xsdbase.py", line 190, in parse_error
    raise error
xmlschema.validators.exceptions.XMLSchemaParseError: <Element '{http://fixprotocol.io/2016/sbe}messageSchema' at 0x7ff525442b60> is not an element of the schema:

Schema:

  <sbe:messageSchema xmlns:sbe="http://fixprotocol.io/2016/sbe" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" byteOrder="bigEndian" id="9" package="com.memx.us_options.memo.sbe.v1_1" semanticVersion="1.1" version="257" xsi:schemaLocation="http://fixprotocol.io/2016/sbe">
  <types>
  <enum encodingType="uint8" name="BooleanType">
  <validValue name="False">0</validValue>
  <validValue name="True">1</validValue>
  </enum>
  <composite name="PriceType">
  <type name="Exponent" presence="constant" primitiveType="int8">-8</type>
  <type name="Mantissa" primitiveType="uint64" />
  </composite>
  <composite name="ShortPriceType">
  <type name="Exponent" presence="constant" primitiveType="int8">-2</type>
  <type name="Mantissa" primitiveType="uint16" />
  </composite>
  <composite name="UTCTimestampNanos">
  <type name="Unit" presence="constant" primitiveType="uint8">9</type>
  <type name="Time" primitiveType="uint64" />
  </composite>
  <composite name="RepeatingGroupDimensions">
  <type name="blockLength" primitiveType="uint8" />
  ...
  ...
  </sbe:messageSchema>

Path: /sbe:messageSchema



