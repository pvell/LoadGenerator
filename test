import struct

# Decode boolean value
def decode_boolean(buffer, offset):
    value = struct.unpack_from('>B', buffer, offset)[0]
    return value != 0, offset + 1

def decode_price(buffer, offset):
    presence = struct.unpack_from('>B', buffer, offset)[0]
    offset += 1

    if presence == 0:
        return None, offset

    exponent = struct.unpack_from('>b', buffer, offset)[0]
    offset += 1

    mantissa_bytes = buffer[offset:offset + 8]
    mantissa = int.from_bytes(mantissa_bytes, byteorder='big', signed=False)

    price_value = mantissa * pow(10, exponent)
    offset += 8

    return price_value, offset

# Decode short price value
def decode_short_price(buffer, offset):
    exponent = struct.unpack_from('>b', buffer, offset)[0]
    mantissa = struct.unpack_from('>H', buffer, offset + 1)[0]
    value = mantissa * 10 ** exponent
    return value, offset + 3


# Decode UTC timestamp in nanoseconds
def decode_utc_timestamp_nanos(buffer, offset):
    unit = struct.unpack_from('>B', buffer, offset)[0]
    time = struct.unpack_from('>Q', buffer, offset + 1)[0]
    return time, offset + 9

# Decode repeating group dimensions
def decode_repeating_group_dimensions(buffer, offset):
    block_length = struct.unpack_from('>H', buffer, offset)[0]
    num_in_group = struct.unpack_from('>H', buffer, offset + 2)[0]
    return block_length, num_in_group, offset + 4

# Decode enumeration value
def decode_enum(buffer, offset, encoding_type):
    if encoding_type == 'uint8':
        value = struct.unpack_from('>B', buffer, offset)[0]
        return value, offset + 1
    elif encoding_type == 'char':
        value = struct.unpack_from('>c', buffer, offset)[0]
        return value.decode('utf-8'), offset + 1
    elif encoding_type == 'uint16':
        value = struct.unpack_from('>H', buffer, offset)[0]
        return value, offset + 2
    else:
        raise ValueError('Unsupported encoding type: ' + encoding_type)

# Example usage
buffer = b'\x01\x00\x00\x00\x00\x00\x00\x00\x00'
offset = 0

boolean_value, offset = decode_boolean(buffer, offset)
print('Boolean value:', boolean_value)

price_value, offset = decode_price(buffer, offset)
print('Price value:', price_value)

short_price_value, offset = decode_short_price(buffer, offset)
print('Short price value:', short_price_value)

utc_timestamp, offset = decode_utc_timestamp_nanos(buffer, offset)
print('UTC timestamp (nanoseconds):', utc_timestamp)

block_length, num_in_group, offset = decode_repeating_group_dimensions(buffer, offset)
print('Block length:', block_length)
print('Number in group:', num_in_group)

enum_value, offset = decode_enum(buffer, offset, 'uint8')
print('Enum value:', enum_value)






(myenv) pvellanki@qa2434:~/loadgenerator/sbe$ python3 sbe_encoder.py 
Encoded message: b'\x00\x01\x00\x00'



import struct
import xml.etree.ElementTree as ET


def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_name = message_elem.get('name')
        fields = {}

        for field_elem in message_elem.findall(f'.//{namespace}field'):
            field_id = int(field_elem.get('id'))
            field_type = field_elem.get('type')
            fields[field_id] = field_type

        messages[message_name] = fields

    return messages


def decode_field(buffer, offset, field_type):
    if field_type == 'int8':
        value = struct.unpack_from('>b', buffer, offset)[0]
        return value, offset + 1
    elif field_type == 'int16':
        value = struct.unpack_from('>h', buffer, offset)[0]
        return value, offset + 2
    elif field_type == 'int32':
        value = struct.unpack_from('>i', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'int64':
        value = struct.unpack_from('>q', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'uint8':
        value = struct.unpack_from('>B', buffer, offset)[0]
        return value, offset + 1
    elif field_type == 'uint16':
        value = struct.unpack_from('>H', buffer, offset)[0]
        return value, offset + 2
    elif field_type == 'uint32':
        value = struct.unpack_from('>I', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'uint64':
        value = struct.unpack_from('>Q', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'float':
        value = struct.unpack_from('>f', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'double':
        value = struct.unpack_from('>d', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'string':
        str_length = struct.unpack_from('>H', buffer, offset)[0]
        str_value = struct.unpack_from(f'>{str_length}s', buffer, offset + 2)[0].decode('ascii')
        return str_value, offset + 2 + str_length
    else:
        raise ValueError(f"Unknown field type: {field_type}")


def decode_message(buffer, offset, schema, message_name):
    if message_name not in schema:
        raise ValueError(f"Message '{message_name}' not found in the schema.")

    fields = schema[message_name]

    decoded_fields = {}
    while offset < len(buffer):
        field_id = struct.unpack_from('>H', buffer, offset)[0]
        offset += 2

        if field_id in fields:
            field_type = fields[field_id]
            value, offset = decode_field(buffer, offset, field_type)
            decoded_fields[field_id] = value
        else:
            raise ValueError(f"Field ID {field_id} not found in the schema for message '{message_name}'.")

    return decoded_fields, offset


# Example usage
schema_file = 'schema.xml'
buffer = b'\x00\x01\x00\x00'
offset = 0
message_name = 'NewOrderSingle'

schema = load_schema(schema_file)

decoded_fields, offset = decode_message(buffer, offset, schema, message_name)

print("Decoded fields:")
for field_id, value in decoded_fields.items():
    print(f"Field ID: {field_id}, Value: {value}")

