

class MyApplication(fix.Application):
    def __init__(self, message_weights, message_rate):
        # Existing code...
        self.captured_clordids = []  # Initialize an empty list to store the captured ClOrdIDs



class MyApplication(fix.Application):
    # Existing code...

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True
                
                # Extract ClOrdID and OrdID from the execution report
                clordid = cl_ord_id.getString()
                ordid = exec_report.getField(fix.OrderID()).getString()

                # Write ClOrdID and OrdID to the text file
                self.write_clordid_ordid_to_file(clordid, ordid)

                # Store the captured ClOrdID in the list
                self.captured_clordids.append(clordid)


class MyApplication(fix.Application):
    # Existing code...

    def generate_message(self, message_type, session_id):
   
        # ... (your existing code)

        elif message_type.lower() == "ordercancel":
            # Generate OrderCancelRequest message using captured ClOrdIDs
            if self.captured_clordids:
                clordid = random.choice(self.captured_clordids)
                message = fix.Message()
                message.getHeader().setField(fix.BeginString(session_id.getBeginString().getString()))
                message.getHeader().setField(fix.MsgType(fix.MsgType_OrderCancelRequest))
                message.getHeader().setField(fix.SenderCompID(session_id.getSenderCompID().getString()))
                message.getHeader().setField(fix.TargetCompID(session_id.getTargetCompID().getString()))
                message.getHeader().setField(fix.MsgSeqNum(self.get_outgoing_seq_num(session_id)))

                message.setField(fix.OrigClOrdID(clordid))
                # Set other fields for the OrderCancelRequest message

            else:
                message = None

            return message

    def generate_and_send_order_cancels(self):
        for clordid in self.captured_clordids:
            cancel_message = self.generate_message("ordercancel", session_id)  # Use the modified generate_message function
            if cancel_message:
                fix.Session.sendToTarget(cancel_message, session_id)

    # ... (the rest of your existing code)












symbols = config.get("LoadGenerator", "symbols").split(",")
    selected_symbol = random.choice(symbols)
message.setField(fix.Symbol(selected_symbol))


import random

          random_quantity = random.randint(1, 1000)
            message.setField(fix.OrderQty(random_quantity))
            
            # Randomize the price between 1 and 100
            random_price = round(random.uniform(1, 100), 2)
            message.setField(fix.Price(random_price))




get efid from connections.cfg file:

efid = self.efid_map.get(session_id.getSenderCompID().getString(), "")  # Get EFID based on SenderCompID
def load_efid_map(self, config_file):
    config = configparser.ConfigParser()
    config.read(config_file)

    sender_comp_ids = []

    for section in config.sections():
        if 'SenderCompID' in config[section]:
            sender_comp_ids.append(config[section]['SenderCompID'])

    for sender_comp_id in sender_comp_ids:
        for section in config.sections():
            if 'SenderCompID' in config[section] and config[section]['SenderCompID'] == sender_comp_id:
                if 'EFID' in config[section]:
                    efid = config[section]['EFID']
                    self.efid_map[sender_comp_id] = efid
                break  # Stop searching once a matching section is found











SBE FUNCTIONAL ISSUES:

1.Update dictionary to have right message types:
2. update send_receive function as below:

def send_and_receive(self, message_type, message):
    # Send the message over the TCP connection
    send_message(self.client_socket, message)

    # Receive the first 10 bytes of the response message
    response_header = self.client_socket.recv(10)

    # Decode the template ID from the 5th byte
    template_id = struct.unpack_from('!B', response_header, 4)[0]

    # Assuming response_length is calculated properly, receive the remaining response
    response_length = struct.unpack_from('!H', response_header, 1)[0]
    remaining_bytes = response_length - 10
    response_message = response_header + self.client_socket.recv(remaining_bytes)

    # Decode the message type based on the template ID
    decoded_message_type = None
    for message_name, message_template_id in MESSAGE_TYPES.items():
        if message_template_id == template_id:
            decoded_message_type = message_name
            break

    if decoded_message_type is not None:
        print(f"Decoded Message Type: {decoded_message_type}")

    # You can now process the decoded_message_type and response_message as needed



# Initialize the FIX application
app = MyApplication(message_weights, message_rate)
app.connection_config_file = connection_config_file
app.send_duration = send_duration
app.load_efid_map(connection_config_file) 

