import json
import time
import socket
import random
import threading
from datetime import datetime
import xml.etree.ElementTree as ET
import struct

# Configuration
config_file = 'session_config.json'
schema_file = 'sbe-schema.xml'
message_rate = 10  # Messages per second

# Global variables
schema = None
session_config = None
stop_event = threading.Event()

# Load schema
def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_id = int(message_elem.get('id'))
        message_name = message_elem.get('name')
        fields = {}

        for field_elem in message_elem.findall(f'.//{namespace}field'):
            field_id = int(field_elem.get('id'))
            field_name = field_elem.get('name')
            field_type = field_elem.get('type')
            fields[field_name] = {'id': field_id, 'type': field_type}

        messages[message_name] = {'id': message_id, 'fields': fields}

    return messages

# Load session configuration from file
def load_session_config(config_file):
    with open(config_file, 'r') as file:
        config_data = json.load(file)
    return config_data

# Encode field
def encode_field(field_type, value):
    # Same as before (using your encode_field function)

# Encode message
def encode_message(schema, message_name, field_values):
    # Same as before (using your encode_message function)

# Connect to the server
def connect():
    global session_config

    try:
        # Create a TCP/IP socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_address = (session_config['ip'], session_config['port'])

        # Connect the socket to the server address
        sock.connect(server_address)
        print('Connected to {}:{}'.format(*server_address))
        return sock
    except Exception as e:
        print('Error connecting to the server:', str(e))
        return None

# Perform login
def login(sock):
    global schema, session_config

    try:
        # Construct and send LoginRequest message
        login_request = {
            'Username': session_config['username'],
            'Password': session_config['password']
        }
        encoded_login_request = encode_message(schema, 'LoginRequest', login_request)
        sock.sendall(encoded_login_request)
        print('Sent LoginRequest')

        # Wait for and decode the response
        response = sock.recv(1024)
        decoded_response, _ = decode_message(response, 0, schema)
        print('Received LoginResponse:', decoded_response)
    except Exception as e:
        print('Error performing login:', str(e))

# Generate NewOrderSingle messages at a specified rate
def generate_messages(sock):
    global schema

    try:
        while not stop_event.is_set():
            # Construct a random NewOrderSingle message
            new_order_single = {
                'SendingTime': int(datetime.now().timestamp() * 1000000000),
                'ClOrdID': 'CLORD' + str(random.randint(1, 100000)),
                'Symbol': 'AAPL',
                'Side': random.choice(['Buy', 'Sell']),
                'OrderQty': random.randint(1, 100),
                'Price': round(random.uniform(100.0, 200.0), 2)
            }
            encoded_new_order_single = encode_message(schema, 'NewOrderSingle', new_order_single)
            sock.sendall(encoded_new_order_single)
            print('Sent NewOrderSingle:', new_order_single)

            # Sleep for the specified message rate
            time.sleep(1 / message_rate)
    except Exception as e:
        print('Error generating messages:', str(e))

# Main execution
if __name__ == '__main__':
    # Load schema and session configuration
    schema = load_schema(schema_file)
    session_config = load_session_config(config_file)

    # Connect to the server
    sock = connect()
    if not sock:
        exit(1)

    # Perform login
    login(sock)

    # Start generating messages
    generator_thread = threading.Thread(target=generate_messages, args=(sock,))
    generator_thread.start()

    # Wait for user interruption
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print('Stopping...')
        stop_event.set()
        generator_thread.join()

    # Close the socket
    sock.close()
