import configparser
import socket
import struct
import time
from sbe_encoder_decoder import *
from random import choices, randint
import string

# Read configuration from config.ini
config = configparser.ConfigParser()
config.read('config.ini')

# Read connection details from connections.cfg
connection_config = configparser.ConfigParser()
connection_config.read(config['Server']['config_file'])

# Read underliers and associated option security ids
underliers_and_options = {}
for underlier, options in config.items('OptionsSecurityIDs'):
    underliers_and_options[underlier] = options.split(',')



# Establish SBE TCP session
def establish_session(session_name):
    # Get connection details for the specified session name
    host = connection_config[session_name]['host']
    port = int(connection_config[session_name]['port'])
    user = connection_config[session_name]['user']
    password = connection_config[session_name]['password']
    token = f'{user}:{password}'

    # Login request
    message_type = 100
    token_type = 'P'
    token_length = len(token)
    header = struct.pack('!BHB', message_type, token_length + 1, token_type.encode('utf-8')[0])
    message = header + token.encode('utf-8')

    # Create a socket and establish the connection
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))
    client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

    # Send the login request
    client_socket.sendall(message)

    # Receive and handle the response (login accepted or rejected)
    response_header = client_socket.recv(3)
    response_type, response_length = struct.unpack('!B H', response_header)
    print(response_type, response_length)

    if response_type == 1:  # Login Accepted
        response_message = client_socket.recv(response_length)
        print("Login Accepted:", response_message.decode('utf-8'))
        session_id = None
    elif response_type == 2:  # Login Rejected
        response_message = client_socket.recv(response_length)
        print("Login Rejected:", response_message.decode('utf-8'))
        client_socket.close()
        exit()  # Exit the script gracefully after login rejection
    else:
        print("Invalid response received.")
        client_socket.close()
        exit()  # Exit the script if an invalid response is received

    # Continue with the session
    while True:
        response_header = client_socket.recv(11)
        response_type, response_length, session_id = struct.unpack('!B H Q', response_header)
        print(response_header, response_type, response_length)

        if response_type == 3:  # Start of Session
            print("Start of Session. Session ID:", session_id)
            break
        else:
            print("Invalid response received.")

    return client_socket, session_id

# Generate and send messages for NewOrderSingle
def send_new_order_single(client_socket, session_id, options_security_id, underlier,session_name):
    for order_number in range(15):
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_letters + string.digits, k=20))
        side = SideType(value=SideType.BUY)
        order_qty = randint(1, 10)
        ord_type = OrdType(value=OrdType.LIMIT)
        price_value = UINT32(order_number)
        print(order_number)
        realprice = price_value.value * 10**14
        price = PriceType(realprice)
        print(realprice,price)
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.CUSTOMER)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        no_parties_groups = 2

        new_order_single = NewOrderSingle(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            options_security_id=options_security_id,
            side=side,
            order_qty=order_qty,
            ord_type=ord_type,
            price=price,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            parties_group=parties,
            party_entries=no_parties_groups
        )

        messageLength = 73 + (18 * (no_parties_groups))
        unsequenced_message = struct.pack('!BH', 104, messageLength)  # MessageType=104, MessageLength=91, TCP Header Length=102
        # Encode the NewOrderSingle instance
        encoded_message = new_order_single.encode()
        message = unsequenced_message + encoded_message

        client_socket.sendall(message)
        time.sleep(0.2)  # Sleep for a short period between each message

    # Update price for sell orders
    for order_number in range(15):
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_letters + string.digits, k=20))
        side = SideType(value=SideType.SELL)
        order_qty = randint(1, 10)
        ord_type = OrdType(value=OrdType.LIMIT)
        price_value = UINT32(order_number)
        realprice = price_value.value * 10**14
        price = PriceType(realprice)
        print(realprice,price)
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.CUSTOMER)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        no_parties_groups = 2

        new_order_single = NewOrderSingle(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            options_security_id=options_security_id,
            side=side,
            order_qty=order_qty,
            ord_type=ord_type,
            price=price,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            parties_group=parties,
            party_entries=no_parties_groups
        )

        messageLength = 73 + (18 * (no_parties_groups))
        unsequenced_message = struct.pack('!BH', 104, messageLength)  # MessageType=104, MessageLength=91, TCP Header Length=102
        # Encode the NewOrderSingle instance
        encoded_message = new_order_single.encode()
        message = unsequenced_message + encoded_message

        client_socket.sendall(message)
        time.sleep(0.2)  # Sleep for a short period between each message

def main():
    # Iterate over session names and establish sessions
    for session_name in connection_config.sections():
        print(f"Processing session: {session_name}")
        try:
            # Establish SBE TCP session for the current session name
            client_socket, session_id = establish_session(session_name)

            # Generate and send messages for NewOrderSingle for each underlier and associated option security ids
            for underlier, option_security_ids in underliers_and_options.items():
                for option_security_id in option_security_ids:
                    send_new_order_single(client_socket, session_id, option_security_id, underlier,session_name)

            # Close the TCP connection for the current session
            client_socket.close()

        except Exception as e:
            print(f"Failed to establish session for {session_name}: {str(e)}")

if __name__ == '__main__':
    main()



