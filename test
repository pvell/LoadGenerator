import socket
import struct
import time
from sbe_tool import encode_message, load_schema

# Load the SBE schema
schema_file = 'sbe-schema.xml'
schema = load_schema(schema_file)

# Define the server host and port
server_host = 'localhost'
server_port = 12345

# Define the field values for the Login Request message
login_fields = {
    3: 'P',  # Token Type: 'P' (Static Password)
    4: 'expro01:expro_01pwd'  # Token: 'expro01:expro_01pwd'
}

# Define the field values for the NewOrderSingle message
new_order_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    11: "CLORD12345",  # ClOrdID
    21035: "SECURITY123",  # OptionsSecurityID
    54: "BUY",  # Side
    38: 100,  # OrderQty
    40: "LIMIT",  # OrdType
    59: "DAY",  # TimeInForce
    18: "ADD",  # ExecInst
    1815: "MEDIUM",  # TradingCapacity
    453: [  # Parties
        {
            448: "PARTY1",  # PartyID
            447: "SRC1",  # PartyIDSource
            452: 1  # PartyRole
        },
        {
            448: "PARTY2",  # PartyID
            447: "SRC2",  # PartyIDSource
            452: 2  # PartyRole
        }
    ]
}

# Define the message rate in messages per second
message_rate = 10

# Create a client socket and connect to the server
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((server_host, server_port))

# Encode and send the Login Request message
login_message_name = 'LoginRequest'
encoded_login_message = encode_message(schema, login_message_name, login_fields)
client_socket.send(encoded_login_message)

# Wait for the Login Accepted message
response_header = client_socket.recv(3)
response_type, response_length = struct.unpack('!BB', response_header)

# ... Handle the response, check if login was accepted ...

# Start the message sending loop
start_time = time.time()
message_count = 0

while True:
    # Encode and send the NewOrderSingle message
    new_order_message_name = 'NewOrderSingle'
    encoded_new_order_message = encode_message(schema, new_order_message_name, new_order_fields)
    client_socket.send(encoded_new_order_message)

    message_count += 1

    # Calculate the elapsed time and check if the desired rate is reached
    elapsed_time = time.time() - start_time
    target_time = message_count / message_rate

    if elapsed_time < target_time:
        # Wait for the remaining time to achieve the desired rate
        time.sleep(target_time - elapsed_time)

# ... Handle the response for each sent message ...

# Close the client socket
client_socket.close()




2023-06-13T14:18:28-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:18:28.111478963 UTC gc22075 [ERROR] MIDS - MEMO_EP6SBE02 - SERVER:CUSTOMER - CHANNEL:CUSTOMER-TCP - 10.2.44.1:39700 - Read timed out for client 10.2.44.1:39700 -- PendingReadBuffer: [00 01 00 ...] +197 more bytes, MessageType=0 (Heartbeat), MessageLength=256
2023-06-13T14:18:28-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:18:28.111875947 UTC gc22075 [INFO ] MIDS - MEMO_EP6SBE02 - Client logged out: { Local=10.2.128.10:30076, Remote=10.2.44.1:39700, State=Closed }
2023-06-13T14:20:43-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:20:43.351103465 UTC gc22075 [INFO ] MIDS - MEMO_EP6SBE02 - SERVER:CUSTOMER - CHANNEL:CUSTOMER-TCP - 10.2.44.1:52514 - Accepting new ServerClient
2023-06-13T14:20:43-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:20:43.351202169 UTC gc22075 [INFO ] MIDS - MEMO_EP6SBE02 - Client logged in: { Local=10.2.128.10:30076, Remote=10.2.44.1:52514, State=Login }
2023-06-13T14:20:48-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:20:48.351027492 UTC gc22075 [ERROR] MIDS - MEMO_EP6SBE02 - SERVER:CUSTOMER - CHANNEL:CUSTOMER-TCP - 10.2.44.1:52514 - Read timed out for client 10.2.44.1:52514 -- PendingReadBuffer: [00 01 00 ...] +157 more bytes, MessageType=0 (Heartbeat), MessageLength=256
2023-06-13T14:20:48-04:00 gc22075.equities.ewr2.memx.tech sh[60131]: 2023/06/13 18:20:48.351061064 UTC gc22075 [INFO ] MIDS - MEMO_EP6SBE02 - Client logged out: { Local=10.2.128.10:30076, Remote=10.2.44.1:52514, State=Closed }



Login Accepted:
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
b'\x00\x01\x00\x00'
Traceback (most recent call last):
  File "/home/pvellanki/loadgenerator/sbe/test4.py", line 99, in <module>
    client_socket.send(encoded_new_order_message)
ConnectionResetError: [Errno 104] Connection reset by peer
