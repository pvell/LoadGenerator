import xml.etree.ElementTree as ET

def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_id = int(message_elem.get('id'))
        message_name = message_elem.get('name')
        fields = {}

        for field_elem in message_elem.findall(f'{namespace}field'):
            field_id = int(field_elem.get('id'))
            field_name = field_elem.get('name')
            field_type = field_elem.get('type')
            fields[field_name] = {'id': field_id, 'type': field_type}

        messages[message_name] = {'id': message_id, 'fields': fields}

    return messages

def encode_message(schema_file, message_name, field_values):
    schema = load_schema(schema_file)
    message = schema.get(message_name)
    if not message:
        raise ValueError(f"Invalid message name '{message_name}'")

    encoded_fields = []
    for field_name, field_data in message['fields'].items():
        field_id = field_data['id']
        field_type = field_data['type']
        field_value = field_values.get(field_name, None)
        encoded_field = encode_field(field_id, field_value, field_type, schema)
        encoded_fields.append(encoded_field)

    encoded_message = ''.join(encoded_fields)
    return encoded_message

def encode_field(field_id, field_value, field_type, schema):
    if field_value is None:
        field_value = ''

    encoded_value = ''
    if field_type == 'string':
        encoded_value = str(field_value)
    elif field_type == 'int':
        encoded_value = str(field_value) if field_value is not None else '0'
    elif field_type == 'float':
        encoded_value = str(field_value) if field_value is not None else '0.0'
    elif field_type == 'composite':
        composite_fields = schema.get(field_value)
        if not composite_fields:
            raise ValueError(f"Invalid composite field '{field_value}'")
        for sub_field_name, sub_field_data in composite_fields.items():
            sub_field_id = sub_field_data['id']
            sub_field_type = sub_field_data['type']
            sub_field_value = field_values.get(sub_field_name, None)
            encoded_sub_field = encode_field(sub_field_id, sub_field_value, sub_field_type, schema)
            encoded_value += encoded_sub_field

    return encoded_value

# Example usage
schema_file = 'sbe-schema-options.xml'
message_name = 'NewOrderSingle'
field_values = {
    'ClOrdID': 'CLORD12345',
    'MPID': 'MPID123',
    'Symbol': 'AAPL',
    'SymbolSfx': None,
    'Side': 'BUY',
    'OrderQty': 100,
    'OrdType': 'LIMIT',
    'Price': 99.99,
    'TimeInForce': 'DAY',
    'OrderCapacity': 'AGENCY',
    'CustOrderCapacity': 'RETAIL'
}

encoded_message = encode_message(schema_file, message_name, field_values)
print('Encoded Message:', encoded_message)


{'NewOrderSingle': {'id': 1, 'fields': {52: 'UTCTimestampNanos', 11: 'NewOrderSingleClOrdID', 21035: 'NewOrderSingleOptionsSecurityID', 54: 'SideType', 38: 'uint32', 40: 'OrdType', 44: 'PriceType', 59: 'TimeInForceType', 77: 'OpenOrCloseType', 18: 'ExecInstType', 1815: 'TradingCapacityType', 21020: 'RepriceFrequencyType', 21021: 'RepriceBehaviorType', 2362: 'uint16', 21001: 'MatchTradePreventionType', 21000: 'uint16', 21005: 'uint16', 448: 'NewOrderSinglePartyID', 447: 'char', 452: 'uint8'}}, 'ShortTwoSidedBulkQuote': {'id': 2, 'fields': {52: 'UTCTimestampNanos', 11: 'ShortTwoSidedBulkQuoteClOrdID', 59: 'TimeInForceType', 18: 'ExecInstType', 1815: 'TradingCapacityType', 2362: 'uint16', 21001: 'MatchTradePreventionType', 21000: 'uint16', 21005: 'uint16', 448: 'ShortTwoSidedBulkQuotePartyID', 447: 'char', 452: 'uint8', 67: 'uint8', 21035: 'ShortTwoSidedBulkQuoteOptionsSecurityID', 134: 'uint16', 132: 'ShortPriceType', 135: 'uint16', 133: 'ShortPriceType'}}, 'LongTwoSidedBulkQuote': {'id': 3, 'fields': {52: 'UTCTimestampNanos', 11: 'LongTwoSidedBulkQuoteClOrdID', 59: 'TimeInForceType'
