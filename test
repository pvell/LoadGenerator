import xml.etree.ElementTree as ET
import struct


def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_id = int(message_elem.get('id'))
        message_name = message_elem.get('name')
        fields = {}

        for field_elem in message_elem.findall(f'.//{namespace}field'):
            field_id = int(field_elem.get('id'))
            field_name = field_elem.get('name')
            field_type = field_elem.get('type')
            fields[field_name] = {'id': field_id, 'type': field_type}

        messages[message_name] = {'id': message_id, 'fields': fields}

    return messages


def encode_field(field_type, value):
    if field_type == 'char':
        return struct.pack('>c', value.encode('ascii'))
    elif field_type == 'int8':
        return struct.pack('>b', value)
    elif field_type == 'int16':
        return struct.pack('>h', value)
    elif field_type == 'int32':
        return struct.pack('>i', value)
    elif field_type == 'int64':
        return struct.pack('>q', value)
    elif field_type == 'uint8':
        return struct.pack('>B', value)
    elif field_type == 'uint16':
        return struct.pack('>H', value)
    elif field_type == 'uint32':
        return struct.pack('>I', value)
    elif field_type == 'uint64':
        return struct.pack('>Q', value)
    elif field_type == 'float':
        return struct.pack('>f', value)
    elif field_type == 'double':
        return struct.pack('>d', value)
    elif field_type == 'string':
        return value.encode('ascii')
    else:
        raise ValueError(f"Unknown field type: {field_type}")


def encode_message(schema, message_name, field_values):
    if message_name not in schema:
        raise ValueError(f"Message '{message_name}' not found in the schema.")

    message = schema[message_name]
    message_id = message['id']
    fields = message['fields']

    encoded_fields = []
    for field_name, field_value in field_values.items():
        if field_name in fields:
            field = fields[field_name]
            field_id = field['id']
            field_type = field['type']
            encoded_field = encode_field(field_type, field_value)
            encoded_fields.append((field_id, encoded_field))
        else:
            raise ValueError(f"Field '{field_name}' not found in the schema for message '{message_name}'.")

    encoded_message = struct.pack('>H', message_id)
    encoded_message += struct.pack('>H', len(encoded_fields))

    for field_id, encoded_field in encoded_fields:
        encoded_message += struct.pack('>H', field_id)
        encoded_message += struct.pack('>H', len(encoded_field))
        encoded_message += encoded_field

    return encoded_message


def decode_field(buffer, offset, field_type):
    if field_type == 'char':
        value = struct.unpack_from('>c', buffer, offset)[0].decode('ascii')
        return value, offset + 1
    elif field_type == 'int8':
        value = struct.unpack_from('>b', buffer, offset)[0]
        return value, offset + 1
    elif field_type == 'int16':
        value = struct.unpack_from('>h', buffer, offset)[0]
        return value, offset + 2
    elif field_type == 'int32':
        value = struct.unpack_from('>i', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'int64':
        value = struct.unpack_from('>q', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'uint8':
        value = struct.unpack_from('>B', buffer, offset)[0]
        return value, offset + 1
    elif field_type == 'uint16':
        value = struct.unpack_from('>H', buffer, offset)[0]
        return value, offset + 2
    elif field_type == 'uint32':
        value = struct.unpack_from('>I', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'uint64':
        value = struct.unpack_from('>Q', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'float':
        value = struct.unpack_from('>f', buffer, offset)[0]
        return value, offset + 4
    elif field_type == 'double':
        value = struct.unpack_from('>d', buffer, offset)[0]
        return value, offset + 8
    elif field_type == 'string':
        str_length = struct.unpack_from('>H', buffer, offset)[0]
        str_value = struct.unpack_from(f'>{str_length}s', buffer, offset + 2)[0].decode('ascii')
        return str_value, offset + 2 + str_length
    else:
        raise ValueError(f"Unknown field type: {field_type}")


def decode_message(buffer, offset, schema):
    message_id = struct.unpack_from('>H', buffer, offset)[0]
    offset += 2

    # Find the message name based on the message ID
    message_name = None
    for name, message in schema.items():
        if message['id'] == message_id:
            message_name = name
            break

    if not message_name:
        raise ValueError(f"Message ID {message_id} not found in the schema.")

    fields = schema[message_name]['fields']

    decoded_fields = {}
    field_count = struct.unpack_from('>H', buffer, offset)[0]
    offset += 2

    for _ in range(field_count):
        field_id = struct.unpack_from('>H', buffer, offset)[0]
        offset += 2

        if field_id in fields.values():
            field_name = None
            for name, field in fields.items():
                if field['id'] == field_id:
                    field_name = name
                    break

            if field_name:
                field_type = fields[field_name]['type']
                value, offset = decode_field(buffer, offset, field_type)
                decoded_fields[field_name] = value
        else:
            raise ValueError(f"Field ID {field_id} not found in the schema for message '{message_name}'.")

    return decoded_fields, offset


if __name__ == '__main__':
    schema_file = 'sbe-schema.xml'
    schema = load_schema(schema_file)

    message_name = 'NewOrderSingle'
    field_values = {
        'SendingTime': 1623322435000000000,
        'ClOrdID': "ORDER-1234",
        'OptionsSecurityID': "OPTION-5678",
        'Side': 1,
        'OrderQty': 100,
        'OrdType': 2,
        'Price': 10.5,
        'TimeInForce': 0,
        'OpenOrClose': 1,
        'ExecInst': 3,
        'TradingCapacity': 2,
        'RepriceFrequency': 3,
        'RepriceBehavior': 1,
        'MtpGroupID': 123,
        'MatchTradePrevention': 0,
        'CancelGroupID': 456,
        'RiskGroupID': 789,
        'Parties': [
            {'PartyID': 'PARTY-1', 'PartyIDSource': 'D', 'PartyRole': 2},
            {'PartyID': 'PARTY-2', 'PartyIDSource': 'D', 'PartyRole': 3}
        ]
    }

    encoded_message = encode_message(schema, message_name, field_values)
    print(f"Encoded Message: {encoded_message.hex()}")

    decoded_fields, _ = decode_message(encoded_message, 0, schema)
    print("Decoded Fields:")
    for field_name, field_value in decoded_fields.items():
        print(f"{field_name}: {field_value}")
