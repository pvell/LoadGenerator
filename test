import threading
# ... (other imports)

# Function to handle workload for each session
def session_workload(session_name):
    try:
        # Establish SBE TCP session for the current session name
        client_socket, session_id = establish_session(session_name)

        # ... (rest of the workload logic)
        # Generate and send messages for the specified duration
        while time.time() - start_time < duration:
            # Generate a random message type
            message_type = generate_message_type()

            # Generate a message based on the random message type
            message = generate_message(message_type, session_name)

            # Send the generated message over the TCP connection
            send_message(client_socket, message)

            # Sleep for a short period to control the message rate
            time.sleep(1 / message_rate)

        # Close the TCP connection for the current session
        client_socket.close()

    except Exception as e:
        print(f"Failed to establish session for {session_name}: {str(e)}")

def main():
    # ... (other parts of your main function)

    # List to hold thread objects
    threads = []

    # Iterate over session names and create threads
    for session_name in session_names:
        thread = threading.Thread(target=session_workload, args=(session_name,))
        threads.append(thread)

    # Start all threads
    for thread in threads:
        thread.start()

    # Wait for all threads to finish
    for thread in threads:
        thread.join()

    # Print the number of active sessions
    print(f"Total active sessions: {len(session_names)}")

# Start the main execution
if __name__ == '__main__':
    main()
