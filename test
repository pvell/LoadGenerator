import socket
import struct
import time
from sbe_tool import encode_message, load_schema

# Load the SBE schema
schema_file = 'sbe-schema.xml'
schema = load_schema(schema_file)

# Define the server host and port
server_host = 'localhost'
server_port = 12345

# Define the field values for the Login Request message
login_fields = {
    3: 'P',  # Token Type: 'P' (Static Password)
    4: 'expro01:expro_01pwd'  # Token: 'expro01:expro_01pwd'
}

# Define the field values for the NewOrderSingle message
new_order_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    11: "CLORD12345",  # ClOrdID
    21035: "SECURITY123",  # OptionsSecurityID
    54: "BUY",  # Side
    38: 100,  # OrderQty
    40: "LIMIT",  # OrdType
    59: "DAY",  # TimeInForce
    18: "ADD",  # ExecInst
    1815: "MEDIUM",  # TradingCapacity
    453: [  # Parties
        {
            448: "PARTY1",  # PartyID
            447: "SRC1",  # PartyIDSource
            452: 1  # PartyRole
        },
        {
            448: "PARTY2",  # PartyID
            447: "SRC2",  # PartyIDSource
            452: 2  # PartyRole
        }
    ]
}

# Define the message rate in messages per second
message_rate = 10

# Create a client socket and connect to the server
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((server_host, server_port))

# Encode and send the Login Request message
login_message_name = 'LoginRequest'
encoded_login_message = encode_message(schema, login_message_name, login_fields)
client_socket.send(encoded_login_message)

# Wait for the Login Accepted message
response_header = client_socket.recv(3)
response_type, response_length = struct.unpack('!BB', response_header)

# ... Handle the response, check if login was accepted ...

# Start the message sending loop
start_time = time.time()
message_count = 0

while True:
    # Encode and send the NewOrderSingle message
    new_order_message_name = 'NewOrderSingle'
    encoded_new_order_message = encode_message(schema, new_order_message_name, new_order_fields)
    client_socket.send(encoded_new_order_message)

    message_count += 1

    # Calculate the elapsed time and check if the desired rate is reached
    elapsed_time = time.time() - start_time
    target_time = message_count / message_rate

    if elapsed_time < target_time:
        # Wait for the remaining time to achieve the desired rate
        time.sleep(target_time - elapsed_time)

# ... Handle the response for each sent message ...

# Close the client socket
client_socket.close()




The MEMO SBE header appears on the wire as:				
				
Field	Offset	Length	Type	Description
BlockLength	0	2	UINT16	The number of bytes in the message body (does not include the header bytes).Â Note that MEMO messages do not use repeating groups or variable-length fields.
TemplateID	2	1	UINT8	Identifier of the message template (ie. the message type)
SchemaID	3	1	UINT8	The identifier of a message schema. SchemaID=1 for MEMO version 1
Version	4	2	UINT16	The version number of the message schema that was used to encode a message. MEMX packs two pieces of information into the UNIT16 version field, a major version and a minor update version. So for example a version of 258 = 0x0102 indicates major version 1, minor update 2.
