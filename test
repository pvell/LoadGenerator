 elif message_type == 'AllocationInstruction':
                # Generate AllowInstruction message
                sending_time = UTCTimestampNanos(int(time.time() * 10**9))
                alloc_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
                alloc_type = AllocType(value=AllocType.I)
                alloc_trans_type = AllocTransType(value=AllocTransType.N)
                ref_alloc_id = Char("")
                options_security_id = OptionsSecurityID(choices(security_ids)[0])
                side = SideType(value=SideType.SELL)

                print('sending time:',sending_time.timestamp)
                print('allocation id:',alloc_id)
                print('allocation type:',alloc_type.value)
                print('ref allocation id:',ref_alloc_id.value)
                print('allocation trans type:',alloc_trans_type.value)
                print('optional security id:',options_security_id.value)
                print('side:',side.value)

                # Construct ExecutionAllocationsGroup instances
                execution_allocations = [
                        ExecutionAllocationsGroup(216201369416105991, 100, PriceType(500000000000000)),
                        ExecutionAllocationsGroup(216201369416105992, 50, PriceType(5000000000000))
                ]

                # Construct NestedPartiesGroup instances
                nested_parties = [
                        NestedPartiesGroup("Nested1", "S", PartyRoleType(1)),
                        NestedPartiesGroup("Nested2", "T", PartyRoleType(2))
                ]

                # Construct RequestedAllocationsGroup instances
                requested_allocations = [
                        RequestedAllocationsGroup(10, AllocPositionEffectType("O"), nested_parties),
                        RequestedAllocationsGroup(20, AllocPositionEffectType("C"), [])
                ]

                allocation_instruction = AllocationInstruction(
                        sending_time = sending_time,
                        alloc_id = alloc_id,
                        alloc_type = alloc_type,
                        alloc_trans_type = alloc_trans_type,
                        ref_alloc_id = ref_alloc_id,
                        options_security_id = options_security_id,
                        side = side,
                        execution_allocations = execution_allocations,
                        requested_allocations = requested_allocations
                        )


                encoded_message = allocation_instruction.encode()
                execution_allocations = 2
                nested_parties = 2
                requested_allocations = 2













class ExecutionAllocationsGroup:
    def __init__(self, trade_id, last_qty, last_px):
        self.trade_id = trade_id
        self.last_qty = last_qty
        self.last_px = last_px

    def encode(self):
        return pack('!QIq', self.trade_id, self.last_qty, self.last_px)

class NestedPartiesGroup:
    def __init__(self, nested_party_id, nested_party_id_source, nested_party_role):
        self.nested_party_id = nested_party_id
        self.nested_party_id_source = nested_party_id_source
        self.nested_party_role = nested_party_role

    def encode(self):
        return pack('16s1s1B', self.nested_party_id.encode('utf-8'), self.nested_party_id_source.encode('utf-8'), self.nested_party_role.value)

class RequestedAllocationsGroup:
    def __init__(self, alloc_qty, alloc_position_effect, nested_parties):
        self.alloc_qty = alloc_qty
        self.alloc_position_effect = alloc_position_effect
        self.nested_parties = nested_parties

    def encode(self):
        nested_parties_data = b''.join([np.encode() for np in self.nested_parties])
        return pack('IB', self.alloc_qty, self.alloc_position_effect.value) + nested_parties_data














class ExecutionAllocationsGroup:
    def __init__(self):
        self.entries = []  # Initialize an empty list to store group entries

    def add_entry(self, trade_id, last_qty, last_px):
        self.entries.append((trade_id, last_qty, last_px))

    def encode(self):
        encoded_data = b''  # Initialize an empty bytes object

        for entry in self.entries:
            trade_id, last_qty, last_px = entry
            encoded_data += pack('!QIq', trade_id, last_qty, last_px)

        return encoded_data

class RequestedAllocationsGroup:
    def __init__(self):
        self.entries = []  # Initialize an empty list to store group entries

    def add_entry(self, alloc_qty, alloc_position_effect, nested_parties):
        self.entries.append((alloc_qty, alloc_position_effect, nested_parties))

    def encode(self):
        encoded_data = b''  # Initialize an empty bytes object

        for entry in self.entries:
            alloc_qty, alloc_position_effect, nested_parties = entry
            nested_parties_data = b''.join([np.encode() for np in nested_parties])
            entry_data = pack('IB', alloc_qty, alloc_position_effect.value) + nested_parties_data
            encoded_data += entry_data

        return encoded_data











# Create instances of ExecutionAllocationsGroup and RequestedAllocationsGroup
execution_allocations = ExecutionAllocationsGroup()
requested_allocations = RequestedAllocationsGroup()

# Add entries to these groups
execution_allocations.add_entry(216201369416105991, 100, PriceType(500000000000000))
execution_allocations.add_entry(216201369416105992, 50, PriceType(5000000000000))

nested_parties_1 = [NestedPartiesGroup("Nested1", "S", PartyRoleType(1))]
nested_parties_2 = [NestedPartiesGroup("Nested2", "T", PartyRoleType(2))]

requested_allocations.add_entry(10, AllocPositionEffectType("O"), nested_parties_1)
requested_allocations.add_entry(20, AllocPositionEffectType("C"), nested_parties_2)

# Encode the groups
execution_allocations_data = execution_allocations.encode()
requested_allocations_data = requested_allocations.encode()

# Now you have the encoded data for both groups

