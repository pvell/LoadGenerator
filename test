class MyApplication(fix.Application):

Capturing ClordId's

# ... (Existing code)

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True
                
                # Extract ClOrdID and OrdID from the execution report
                clordid = cl_ord_id.getString()
                ordid = exec_report.getField(fix.OrderID()).getString()

                # Write ClOrdID and OrdID to the text file
                self.write_clordid_ordid_to_file(clordid, ordid)


Adding order cancels:

class MyApplication(fix.Application):
    def __init__(self, message_weights, message_rate):
        # Existing code...
        self.captured_clordids = []  # Initialize an empty list to store the captured ClOrdIDs



class MyApplication(fix.Application):
    # Existing code...

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True
                
                # Extract ClOrdID and OrdID from the execution report
                clordid = cl_ord_id.getString()
                ordid = exec_report.getField(fix.OrderID()).getString()

                # Write ClOrdID and OrdID to the text file
                self.write_clordid_ordid_to_file(clordid, ordid)

                # Store the captured ClOrdID in the list
                self.captured_clordids.append(clordid)




class MyApplication(fix.Application):
    # Existing code...

    def send_order_cancel_request(self, orig_cl_ord_id):
        if not self.captured_clordids:
            print("No captured ClOrdIDs to generate order cancel.")
            return

        # Select a random ClOrdID from the list of captured ClOrdIDs
        selected_clordid = random.choice(self.captured_clordids)

        # Create the OrderCancelRequest message
        message = fix.Message()
        # Set the required fields for OrderCancelRequest
        # For example:
        message.getHeader().setField(fix.MsgType(fix.MsgType_OrderCancelRequest))
        message.setField(fix.ClOrdID(self.generate_clordid()))
        message.setField(fix.OrigClOrdID(selected_clordid))
        # Set other fields as required for the cancel request

        # Send the OrderCancelRequest message
        fix.Session.sendToTarget(message, self.session_id)




def create_session(self, session_settings):
    storeFactory = fix.FileStoreFactory(session_settings)
    logFactory = fix.FileLogFactory(session_settings)
    application = fix.SocketInitiator(self, storeFactory, session_settings, logFactory)
    application.start()
    return application

def run(self):
    settings = fix.SessionSettings(self.connection_config_file)

    for session_id in settings.sections():
        if session_id != "DEFAULT":
            session_settings = settings.get(session_id)
            application = self.create_session(session_settings)
            self.sessions[session_id] = application

    while not all(application.isLoggedOn() for application in self.sessions.values()):
        time.sleep(1)

    load = self.generate_load()

    start_time = time.time()
    message_count = 0

    while True:
        elapsed_time = time.time() - start_time

        if elapsed_time >= self.send_duration:
            break

        if message_count >= len(load):
            message_count = 0

        for session_id in self.sessions:
            application = self.sessions[session_id]

            if application is not None and application.isLoggedOn():
                message = self.generate_message(load[message_count], session_id)
                fix.Session.sendToTarget(message, session_id)
            message_count += 1

        time.sleep(1)

    for application in self.sessions.values():
        application.stop()



import random
import time
import datetime
import os
import configparser
import quickfix as fix

# Global variables
sessions = {}

# Class representing the FIX application
class MyApplication(fix.Application):
    # Your MyApplication code here

class MyInitiator(fix.Application):
    def __init__(self, app, connection_config_file):
        self.app = app
        self.connection_config_file = connection_config_file
        self.session_sequence_numbers = {}

    def onCreate(self, sessionID):
        print("Session created -", sessionID.toString())
        self.app.sessions[sessionID] = fix.Session.lookupSession(sessionID)
        self.session_sequence_numbers[sessionID.toString()] = int(config.get(sessionID.getTargetCompID().getString(), "next_sequence_number"))
        self.app.session_sequence_numbers = self.session_sequence_numbers

    # Implement other methods as needed

    def run(self):
        settings = fix.SessionSettings(self.connection_config_file)
        application = fix.SocketInitiator(self, fix.FileStoreFactory(settings), settings)
        application.start()

        while not all(session.isLoggedOn() for session in self.app.sessions.values()):
            time.sleep(1)

        load = self.app.generate_load()

        start_time = time.time()
        message_count = 0

        while True:
            elapsed_time = time.time() - start_time

            if elapsed_time >= self.app.send_duration:
                break

            if message_count >= len(load):
                message_count = 0

            for session_id in self.app.sessions:
                session = self.app.sessions[session_id]

                if session is not None and session.isLoggedOn():
                    message = self.app.generate_message(load[message_count], session_id)
                    fix.Session.sendToTarget(message, session_id)
                    self.session_sequence_numbers[session_id] += 1

                message_count += 1

            time.sleep(1)

        application.stop()

# Read configuration from config.ini
config = configparser.ConfigParser()
config.read("connection.cfg")

# Load configuration values
connection_config_file = config.get("DEFAULT", "ConnectionConfigFile")
log_file = config.get("DEFAULT", "LogFile")
message_rate = float(config.get("LoadGenerator", "MessageRate"))
send_duration = int(config.get("LoadGenerator", "SendDuration"))

message_weights = dict(config.items("MessageTypes"))

# Initialize the FIX application
app = MyApplication(message_weights, message_rate)
app.connection_config_file = connection_config_file
app.send_duration = send_duration

# Initialize the initiator
initiator = MyInitiator(app, connection_config_file)

# Run the FIX initiator
initiator.run()



import configparser
import time
import datetime
import os
import quickfix as fix

# ... Other parts of your code ...

def parse_custom_config(config_file):
    config = configparser.ConfigParser()
    config.read(config_file)
    custom_sessions = {}

    for section in config.sections():
        if "SenderCompID" in config[section] and "TargetCompID" in config[section]:
            custom_sessions[section] = {
                "SenderCompID": config[section]["SenderCompID"],
                "TargetCompID": config[section]["TargetCompID"]
                # Add other relevant settings here
            }
    
    return custom_sessions

class MyApplication(fix.Application):
    # ... Rest of your MyApplication class ...

def run(self):
    custom_sessions = parse_custom_config(self.connection_config_file)

    for sender_comp_id, session_settings in custom_sessions.items():
        target_comp_id = session_settings["TargetCompID"]
        settings = fix.SessionSettings()
        settings.setString(f"ConnectionType", "initiator")
        settings.setString(f"ReconnectInterval", "10")
        settings.setString(f"FileStorePath", "./Sessions/")
        settings.setString(f"FileLogPath", "log")
        settings.setString(f"BeginString", "FIXT.1.1")
        settings.setString(f"SenderCompID", sender_comp_id)
        settings.setString(f"TargetCompID", target_comp_id)
        # Set other session settings based on your requirements
        
        application = fix.SocketInitiator(self, fix.FileStoreFactory(settings), settings)
        application.start()

        while not application.isLoggedOn():
            time.sleep(1)
    
    while True:
        # Your message generation and sending logic here

# ... Rest of your code ...

if __name__ == '__main__':
    app = MyApplication()
    app.connection_config_file = "connection.cfg"
    app.run()

