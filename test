import socket
import struct
import time
import sbe

# Load the SBE schema
schema_file = 'sbe-schema.xml'
schema = sbe.load_schema(schema_file)

# TCP/IP connection details
host = '10.2.128.10'
port = 30076

# Token and header details
user = 'exactpro6'
password = 'expro6pwd'
token = f'{user}:{password}'

# Login request
message_type = 100
token_type = 'P'  # Assuming token type is always 'P'
token_length = len(token)
header = struct.pack('!BHB', message_type, token_length + 1, token_type.encode('utf-8')[0])
message = header + token.encode('utf-8')

# Create a socket and establish the connection
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((host, port))

# Set socket to binary mode
client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

# Send the login request
client_socket.sendall(message)

# Define the field values for the MassCancelRequest message
mass_cancel_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    # Add the necessary fields for the MassCancelRequest message
    # Example:
    # 21032: <field_value>  # MassCancelInstType
}

# Define the message rate in messages per second
message_rate = 10

# Wait for the Login Accepted message
response_header = client_socket.recv(2)
response_type, response_length = struct.unpack('!BB', response_header)

if response_type == 1:  # Login Accepted
    response_message = client_socket.recv(response_length)
    print("Login Accepted:")
elif response_type == 2:  # Login Rejected
    response_message = client_socket.recv(response_length)
    print("Login Rejected:")
    client_socket.close()
    exit()  # Exit the script gracefully after login rejection
elif response_type == 3:  # Start of Session
    response_message = client_socket.recv(response_length)
    session_id = struct.unpack('!Q', response_message[:8])[0]
    print("Start of Session. Session ID:", session_id)
else:
    print("Invalid response received.")
    client_socket.close()
    exit()  # Exit the script if an invalid response is received

# Start the message sending loop
start_time = time.time()
message_count = 0

while True:
    # Encode and send the MassCancelRequest message
    mass_cancel_message_name = 'MassCancelRequest'
    encoded_mass_cancel_message = sbe.encode_message(schema, mass_cancel_message_name, mass_cancel_fields)
    print(encoded_mass_cancel_message)
    client_socket.send(encoded_mass_cancel_message)

    message_count += 1

    # Calculate the elapsed time and check if the desired rate is reached
    elapsed_time = time.time() - start_time
    target_time = message_count / message_rate

    if elapsed_time < target_time:
        # Wait for the remaining time to achieve the desired rate
        time.sleep(target_time - elapsed_time)

    if message_count >= message_rate:  # Adjust the condition based on your requirements
        break

# ... Handle the response for each sent message ...

# Close the client socket
client_socket.close()




MassCancelRequest						
						
The mass cancel request message requests the cancellation all remaining size on a set of existing orders that match the given criteria.						
						
Note: this message can be used to cancel orders from different accounts. Orders affected by this request may have been entered via either MEMO or MEMO FIX supported protocols.Â 						
						
Field	Offset	Length	Type	Tag Ref Num	Req'd	Description
Field	Offset	Length	Type	Tag Ref Num	Req'd	Description
SBE Header	0	7	SBE Header	N/A	Y	SBE Header with templateID = 8
SendingTime	7	8	UTCTimestampNanos	52	Y	Time of message transmission always expressed in UTC (Universal Time Coordinated, also known as GMT)
ClOrdID	15	16	CHAR	11	Y	A unique identifier for the mass cancel request.
SendCancels	31	1	BOOLEAN	21031	N	If set to true, the exchange will send an ExecutionReport_Canceled message for each order/quote canceled.
						If set to false the exchange will NOT send an ExecutionReport_Canceled resulting from this request.
						The default if this field is not supplied is true.
EFID	32	4	CHAR	21007	N	Cancel all orders on this EFID.
UnderlyingOrSeries	36	1	UnderlyingOrSeriesType	21029	Y	If UnderlyingOrSeries is set to CancelAllOnSeries then OptionsSecurityID must be provided to denote the specific option series (root, put/call, expirtation, and strike price) to cancel orders on. If UnderlyingOrSeries is set to CancelAllOnUnderlying then Symbol (OSI Root) must be provided to denote the OSI Root on which to cancel all orders (across all series)
Symbol (OSIRoot)	37	6	CHAR	55	N	The OSI Root.
OptionsSecurityID	43	8	CHAR	21035	N	The OptionsSecurityID identifying the tradable options product. In this case it is used to identify the entire series the OptionsSecurityID is part of.
CancelGroupID	51	2	UINT16	21000	N	Identifier of custom cancel group.
