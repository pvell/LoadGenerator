import struct

def encode_message(cl_ord_id, mpid, symbol, symbol_sfx, side, order_qty, ord_type, price, time_in_force, order_capacity, cust_order_capacity, exec_inst, peg_offset_value, peg_price_type, expire_time, min_qty, display_qty, display_method, reserve_replenish_timing, display_min_incr, locate_reqd, reprice_frequency, reprice_behavior, cancel_group_id, stp_group_id, self_trade_prevention, risk_group_id, lnk_id):
    encoded_fields = [
        cl_ord_id.encode(),
        mpid.encode() if mpid else b'',
        symbol.encode(),
        symbol_sfx.encode() if symbol_sfx else b'',
        side.encode(),
        struct.pack('I', order_qty),
        ord_type.encode(),
        struct.pack('d', price) if price else b'',
        time_in_force.encode(),
        order_capacity.encode(),
        cust_order_capacity.encode(),
        exec_inst.encode(),
        struct.pack('d', peg_offset_value) if peg_offset_value else b'',
        peg_price_type.encode() if peg_price_type else b'',
        struct.pack('Q', expire_time) if expire_time else b'',
        struct.pack('I', min_qty) if min_qty else b'',
        struct.pack('I', display_qty) if display_qty else b'',
        display_method.encode() if display_method else b'',
        reserve_replenish_timing.encode() if reserve_replenish_timing else b'',
        struct.pack('I', display_min_incr) if display_min_incr else b'',
        locate_reqd.encode() if locate_reqd else b'',
        reprice_frequency.encode() if reprice_frequency else b'',
        reprice_behavior.encode() if reprice_behavior else b'',
        struct.pack('H', cancel_group_id) if cancel_group_id else b'',
        struct.pack('H', stp_group_id) if stp_group_id else b'',
        self_trade_prevention.encode() if self_trade_prevention else b'',
        struct.pack('H', risk_group_id) if risk_group_id else b'',
        lnk_id.encode() if lnk_id else b'',
    ]
    encoded_message = b''.join(encoded_fields)
    return encoded_message

def decode_message(encoded_message):
    cl_ord_id = encoded_message[0:20].decode().strip('\x00')
    mpid = encoded_message[20:28].decode().strip('\x00')
    symbol = encoded_message[28:44].decode().strip('\x00')
    symbol_sfx = encoded_message[44:52].decode().strip('\x00')
    side = encoded_message[52:56].decode().strip('\x00')
    order_qty = struct.unpack('!I', encoded_message[56:60])[0]
    ord_type = encoded_message[60:64].decode().strip('\x00')
    price = struct.unpack('!d', encoded_message[64:72])[0]
    time_in_force = encoded_message[72:76].decode().strip('\x00')

    try:
        cust_order_capacity = encoded_message[76:77].decode().strip('\x00')
    except UnicodeDecodeError:
        cust_order_capacity = ""

    exec_inst = encoded_message[77:81].decode().strip('\x00')
    peg_offset_value = struct.unpack('!d', encoded_message[81:89])[0]
    peg_price_type = encoded_message[89:93].decode().strip('\x00')
    expire_time = struct.unpack('!Q', encoded_message[93:101])[0]
    min_qty = struct.unpack('!I', encoded_message[101:105])[0]
    display_qty = struct.unpack('!I', encoded_message[105:109])[0]
    display_method = encoded_message[109:117].decode().strip('\x00')
    reserve_replenish_timing = encoded_message[117:125].decode().strip('\x00')
    display_min_incr = struct.unpack('!I', encoded_message[125:129])[0]
    locate_reqd = encoded_message[129:130].decode().strip('\x00')
    reprice_frequency = encoded_message[130:138].decode().strip('\x00')
    reprice_behavior = encoded_message[138:146].decode().strip('\x00')
    cancel_group_id = struct.unpack('!H', encoded_message[146:148])[0]
    stp_group_id = struct.unpack('!H', encoded_message[148:150])[0]
    self_trade_prevention = encoded_message[150:154].decode().strip('\x00')
    risk_group_id = struct.unpack('!H', encoded_message[154:156])[0]
    lnk_id = encoded_message[156:172].decode().strip('\x00')

    return {
        'cl_ord_id': cl_ord_id,
        'mpid': mpid,
        'symbol': symbol,
        'symbol_sfx': symbol_sfx,
        'side': side,
        'order_qty': order_qty,
        'ord_type': ord_type,
        'price': price,
        'time_in_force': time_in_force,
        'cust_order_capacity': cust_order_capacity,
        'exec_inst': exec_inst,
        'peg_offset_value': peg_offset_value,
        'peg_price_type': peg_price_type,
        'expire_time': expire_time,
        'min_qty': min_qty,
        'display_qty': display_qty,
        'display_method': display_method,
        'reserve_replenish_timing': reserve_replenish_timing,
        'display_min_incr': display_min_incr,
        'locate_reqd': locate_reqd,
        'reprice_frequency': reprice_frequency,
        'reprice_behavior': reprice_behavior,
        'cancel_group_id': cancel_group_id,
        'stp_group_id': stp_group_id,
        'self_trade_prevention': self_trade_prevention,
        'risk_group_id': risk_group_id,
        'lnk_id': lnk_id
    }



cl_ord_id = "ORDER001"
mpid = "MPID001"
symbol = "AAPL"
symbol_sfx = "SFX001"
side = "Buy"
order_qty = 100
ord_type = "Limit"
price = 100.5
time_in_force = "Day"
order_capacity = "Agency"
cust_order_capacity = "Member"
exec_inst = "FillOrKill"
peg_offset_value = 0.5
peg_price_type = "TrailingStopPeg"
expire_time = 16777216
min_qty = 10
display_qty = 50
display_method = "Initial"
reserve_replenish_timing = "WithOnOpen"
display_min_incr = 5
locate_reqd = "Y"
reprice_frequency = "Daily"
reprice_behavior = "Ignore"
cancel_group_id = 123
stp_group_id = 456
self_trade_prevention = "CancelNewest"
risk_group_id = 789
lnk_id = "LNK001"

encoded_message = encode_message(
    cl_ord_id, mpid, symbol, symbol_sfx, side, order_qty, ord_type, price, time_in_force,
    order_capacity, cust_order_capacity, exec_inst, peg_offset_value, peg_price_type,
    expire_time, min_qty, display_qty, display_method, reserve_replenish_timing, display_min_incr,
    locate_reqd, reprice_frequency, reprice_behavior, cancel_group_id, stp_group_id,
    self_trade_prevention, risk_group_id, lnk_id
)

decoded_fields = decode_message(encoded_message)
print(decoded_fields)



UnicodeDecodeError: 'utf-8' codec can't decode byte 0xe0 in position 0: unexpected end of data
