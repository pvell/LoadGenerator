import struct
import xml.etree.ElementTree as ET

def generate_encoded_message(xml_file, message_name, field_values):
    try:
        # Parse the XML file
        tree = ET.parse(xml_file)
        root = tree.getroot()
    except ET.ParseError as e:
        print(f"Error: Failed to parse XML file: {e}")
        return None

    message = None
    for msg in root.findall('message'):
        if msg.attrib.get('name') == message_name:
            message = msg
            break
    if message is None:
        raise ValueError(f"Message '{message_name}' not found in the XML definition.")

    # Initialize the encoded message with the SBE header
    encoded_message = struct.pack('>H', 0)  # Placeholder for BlockLength
    encoded_message += struct.pack('B', 0)  # Placeholder for TemplateID
    encoded_message += struct.pack('B', 0)  # Placeholder for SchemaID
    encoded_message += struct.pack('>H', 0)  # Placeholder for Version

    # Process the fields and update the encoded message
    encoded_fields = b''
    for field in message.findall('field'):
        field_name = field.attrib.get('name')
        field_type = field.attrib.get('type')
        field_value = field_values.get(field_name)
        if field_value is None:
            raise ValueError(f"Missing value for field '{field_name}'.")

        # Encode the field based on its type
        if field_type == 'string':
            field_length = len(field_value)
            encoded_fields += struct.pack('>H', field_length)
            encoded_fields += field_value.encode()
        elif field_type == 'char':
            encoded_fields += struct.pack('c', field_value.encode())
        elif field_type == 'int':
            encoded_fields += struct.pack('>I', field_value)
        elif field_type == 'float':
            encoded_fields += struct.pack('>f', field_value)
        elif field_type == 'double':
            encoded_fields += struct.pack('>d', field_value)
        # Add more conditionals for other field types as needed

    # Update the SBE header with the actual values
    encoded_message = struct.pack('>H', len(encoded_fields) + 5) + encoded_message[2:]
    encoded_message = encoded_message[:2] + struct.pack('B', message_id) + encoded_message[3:]
    encoded_message = encoded_message[:3] + struct.pack('B', 1) + encoded_message[4:]
    encoded_message = encoded_message[:4] + struct.pack('>H', 266) + encoded_message[6:]

    # Add the encoded fields to the final message
    encoded_message += encoded_fields

    return encoded_message

# Provide the path to your XML file
xml_file_path = 'sbe-schema-equities.xml'

# Example usage
message_name = 'newOrderSingle'
field_values = {
    'ClOrdID': 'ORD123',
    'Symbol': 'AAPL',
    'Side': 'Buy',
    'OrderQty': 100,
    'Price': 150.5
}

encoded_message = generate_encoded_message(xml_file_path, message_name, field_values)
if encoded_message is not None:
    print("Encoded Message:", encoded_message)
