import struct

# Define your MESSAGE_TYPES dictionary
MESSAGE_TYPES = {
    "NewOrderSingle": 1,
    "ShortTwoSidedBulkQuote": 2,
    "LongTwoSidedBulkQuote": 3,
    # ... (your other message types)
    "MassCancelClearLockoutDone": 31
}

def extract_messages_from_tcp_connection(client_socket):
    while True:
        # Read the header to determine message length (3 bytes)
        header = client_socket.recv(3)
        if len(header) < 3:
            # If the header is incomplete, exit the loop
            break

        # Unpack the header
        message_length = struct.unpack('!H', header[1:3])[0]

        # Read the message data based on the message length
        message_data = client_socket.recv(message_length)

        # Ensure we have enough data for the SBE header
        while len(message_data) >= 7:
            # Unpack SBE header from message_data
            block_length, template_id, schema_id, version, num_groups = struct.unpack('!HBBHb', message_data[:7])

            # Determine the message type based on TemplateID
            message_type = None
            for msg_type, template_id_val in MESSAGE_TYPES.items():
                if template_id_val == template_id:
                    message_type = msg_type
                    break

            if message_type is not None:
                # Decode the message based on its type
                decode_message(message_data[7:], message_type)

            # Remove the processed message from the message_data
            message_data = message_data[7 + block_length:]

# Implement the decode_message function as shown in the previous response

# Example usage
# Replace client_socket with your established TCP connection socket
# extract_messages_from_tcp_connection(client_socket)
