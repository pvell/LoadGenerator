import socket
import struct
import time
from sbe_tool import encode_message, load_schema

# Load the SBE schema
schema_file = 'sbe-schema.xml'
schema = load_schema(schema_file)

# Define the server host and port
server_host = 'localhost'
server_port = 12345

# Define the field values for the Login Request message
login_fields = {
    3: 'P',  # Token Type: 'P' (Static Password)
    4: 'expro01:expro_01pwd'  # Token: 'expro01:expro_01pwd'
}

# Define the field values for the NewOrderSingle message
new_order_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    11: "CLORD12345",  # ClOrdID
    21035: "SECURITY123",  # OptionsSecurityID
    54: "BUY",  # Side
    38: 100,  # OrderQty
    40: "LIMIT",  # OrdType
    59: "DAY",  # TimeInForce
    18: "ADD",  # ExecInst
    1815: "MEDIUM",  # TradingCapacity
    453: [  # Parties
        {
            448: "PARTY1",  # PartyID
            447: "SRC1",  # PartyIDSource
            452: 1  # PartyRole
        },
        {
            448: "PARTY2",  # PartyID
            447: "SRC2",  # PartyIDSource
            452: 2  # PartyRole
        }
    ]
}

# Define the message rate in messages per second
message_rate = 10

# Create a client socket and connect to the server
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((server_host, server_port))

# Encode and send the Login Request message
login_message_name = 'LoginRequest'
encoded_login_message = encode_message(schema, login_message_name, login_fields)
client_socket.send(encoded_login_message)

# Wait for the Login Accepted message
response_header = client_socket.recv(3)
response_type, response_length = struct.unpack('!BB', response_header)

# ... Handle the response, check if login was accepted ...

# Start the message sending loop
start_time = time.time()
message_count = 0

while True:
    # Encode and send the NewOrderSingle message
    new_order_message_name = 'NewOrderSingle'
    encoded_new_order_message = encode_message(schema, new_order_message_name, new_order_fields)
    client_socket.send(encoded_new_order_message)

    message_count += 1

    # Calculate the elapsed time and check if the desired rate is reached
    elapsed_time = time.time() - start_time
    target_time = message_count / message_rate

    if elapsed_time < target_time:
        # Wait for the remaining time to achieve the desired rate
        time.sleep(target_time - elapsed_time)

# ... Handle the response for each sent message ...

# Close the client socket
client_socket.close()



def encode_message(schema, message_name, field_values):
    if message_name not in schema:
        raise ValueError(f"Message '{message_name}' not found in the schema.")

    message = schema[message_name]
    message_id = message['id']
    fields = message['fields']

    encoded_fields = []
    for field_id, field_type in fields.items():
        if field_id in field_values:
            value = field_values[field_id]
            encoded_field = encode_field(field_type, value)
            encoded_fields.append((field_id, encoded_field))

    encoded_message = bytearray()
    encoded_message += struct.pack('>H', len(encoded_fields) + 5)  # MEMO SBE header: BlockLength
    encoded_message += struct.pack('B', 1)  # MEMO SBE header: TemplateID
    encoded_message += struct.pack('B', 1)  # MEMO SBE header: SchemaID
    encoded_message += struct.pack('>H', 258)  # MEMO SBE header: Version

    encoded_message += struct.pack('>H', message_id)  # Message ID

    for field_id, encoded_field in encoded_fields:
        encoded_message += struct.pack('>H', field_id)
        encoded_message += struct.pack('>H', len(encoded_field))
        encoded_message += encoded_field

    return encoded_message
    
    
    
def decode_message(schema, encoded_message):
    offset = 0

    # Decode MEMO SBE header
    block_length = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    template_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    schema_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    version = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    # Extract message ID from the encoded message
    message_id = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    if message_id not in schema:
        raise ValueError(f"Message ID '{message_id}' not found in the schema.")

    message_name = schema[message_id]['name']
    fields = schema[message_id]['fields']
    decoded_fields = {}

    # Decode the fields of the message
    while offset < len(encoded_message):
        field_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
        offset += 1

        field_length = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
        offset += 2

        field_value = encoded_message[offset:offset + field_length]
        offset += field_length

        field_type = fields[field_id]
        decoded_value = decode_field(field_type, field_value)

        decoded_fields[field_id] = decoded_value

    return message_name, decoded_fields

