import xml.etree.ElementTree as ET
import struct


def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_id = int(message_elem.get('id'))
        message_name = message_elem.get('name')
        fields = {}

        for field_elem in message_elem.findall(f'.//field'):
            field_id = int(field_elem.get('id'))
            field_type = field_elem.get('type')
            #print(f"Field ID: {field_id}, Field Type: {field_type}")
            fields[field_id] = field_type

        messages[message_name] = {'id': message_id, 'fields': fields}

    print(messages)
    return messages


"""
def load_schema(schema_file):
    tree = ET.parse(schema_file)
    root = tree.getroot()
    messages = {}

    # Find the XML namespace
    namespace = root.tag.split('}')[0] + '}'

    for message_elem in root.findall(f'{namespace}message'):
        message_id = int(message_elem.get('id'))
        message_name = message_elem.get('name')
        fields = []

        for field_elem in message_elem.findall(f'.//{namespace}field'):
            field_id = int(field_elem.get('id'))
            field_name = field_elem.get('name')
            field_type = field_elem.get('type')
            field_description = field_elem.find(f'{namespace}description').text.strip()
            field_required = field_elem.get('presence') == 'required'
            field_encoding = field_elem.get('encoding')
            field_byte_order = field_elem.get('byteOrder')
            field_offset = int(field_elem.get('offset'))
            field_description = field_elem.find(f'{namespace}description').text.strip()

            field = {
                'id': field_id,
                'name': field_name,
                'type': field_type,
                'description': field_description,
                'required': field_required,
                'encoding': field_encoding,
                'byte_order': field_byte_order,
                'offset': field_offset
            }

            fields.append(field)

        messages[message_name] = {'id': message_id, 'fields': fields}
    
    print(messages)
    return messages
"""


def encode_field(field_type, value):
    if field_type in ['NewOrderSingleClOrdID', 'NewOrderSingleMPID', 'NewOrderSingleSymbol', 'NewOrderSingleSymbolSfx', 'NewOrderSingleLnkId']:
        return value.encode('utf-8')
    elif field_type == 'SideType':
        return struct.pack('c', value.encode('utf-8'))
    elif field_type == 'uint32':
        return struct.pack('I', value)
    elif field_type == 'OrdType':
        return struct.pack('b', value)
    elif field_type == 'PriceType':
        return struct.pack('d', value)
    elif field_type == 'TimeInForceType':
        return struct.pack('b', value)
    elif field_type == 'OrderCapacityType':
        return struct.pack('b', value)
    elif field_type == 'CustOrderCapacityType':
        if value == 'MemberTradingOnTheirOwnAccount':
            return struct.pack('B', 1)
        elif value == 'RetailCustomer':
            return struct.pack('B', 5)
        elif value == 'NullValue':
            return struct.pack('B', 255)
        else:
            raise ValueError(f"Invalid value for CustOrderCapacityType: {value}")
    elif field_type == 'ExecInstType':
        return struct.pack('b', value)
    elif field_type == 'PegType':
        return struct.pack('b', value)
    elif field_type == 'UTCTimestampNanos':
        return struct.pack('Q', value)
    elif field_type == 'DispMethodType':
        return struct.pack('b', value)
    elif field_type == 'ReserveReplenishTimingType':
        return struct.pack('b', value)
    elif field_type == 'char':
        return struct.pack('c', value.encode('utf-8'))
    elif field_type == 'RepriceFrequencyType':
        return struct.pack('b', value)
    elif field_type == 'RepriceBehaviorType':
        return struct.pack('b', value)
    elif field_type == 'uint16':
        return struct.pack('H', value)
    elif field_type == 'SelfTradePreventionType':
        return struct.pack('b', value)
    else:
        raise ValueError(f"Unknown field type: {field_type}")





def encode_message(schema, message_name, field_values):
    if message_name not in schema:
        raise ValueError(f"Message '{message_name}' not found in the schema.")

    message = schema[message_name]
    message_id = message['id']
    fields = message['fields']

    encoded_fields = []
    for field_id, field_type in fields.items():
        if field_id in field_values:
            value = field_values[field_id]
            encoded_field = encode_field(field_type, value)
            encoded_fields.append((field_id, encoded_field))

    encoded_message = bytearray()
    encoded_message += struct.pack('>H', len(encoded_fields) + 5)  # MEMO SBE header: BlockLength
    encoded_message += struct.pack('B', 1)  # MEMO SBE header: TemplateID
    encoded_message += struct.pack('B', 1)  # MEMO SBE header: SchemaID
    encoded_message += struct.pack('>H', 266)  # MEMO SBE header: Version

    encoded_message += struct.pack('>H', message_id)  # Message ID

    for field_id, encoded_field in encoded_fields:
        encoded_message += struct.pack('>H', field_id)
        encoded_message += struct.pack('>H', len(encoded_field))
        encoded_message += encoded_field

    return encoded_message




def decode_message(schema, encoded_message):
    offset = 0

    # Decode MEMO SBE header
    block_length = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    template_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    schema_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    version = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    # Extract message ID from the encoded message
    message_id = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    if message_id not in schema:
        raise ValueError(f"Message ID '{message_id}' not found in the schema.")

    fields = schema[message_id]['fields']
    decoded_fields = {}

    # Decode message fields
    for field_id, field_name in fields.items():
        # Decode each field based on its type
        if field_name == 'NewOrderSingleClOrdID':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'NewOrderSingleMPID':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'NewOrderSingleSymbol':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'NewOrderSingleSymbolSfx':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'SideType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'uint32':
            field_value = struct.unpack('>I', encoded_message[offset:offset + 4])[0]
            offset += 4
        elif field_name == 'OrdType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'PriceType':
            field_value = struct.unpack('>d', encoded_message[offset:offset + 8])[0]
            offset += 8
        elif field_name == 'TimeInForceType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'OrderCapacityType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'CustOrderCapacityType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'ExecInstType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'PegType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'UTCTimestampNanos':
            field_value = struct.unpack('>Q', encoded_message[offset:offset + 8])[0]
            offset += 8
        elif field_name == 'DispMethodType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'ReserveReplenishTimingType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'char':
            field_value = struct.unpack('c', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'RepriceFrequencyType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'RepriceBehaviorType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'uint16':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'SelfTradePreventionType':
            field_value = struct.unpack('B', encoded_message[offset:offset + 1])[0]
            offset += 1
        elif field_name == 'RiskGroupId':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        elif field_name == 'NewOrderSingleLnkId':
            field_value = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
            offset += 2
        else:
            raise ValueError(f"Unknown field name '{field_name}' in schema.")

        decoded_fields[field_name] = field_value

    return decoded_fields



def decode_message(schema, encoded_message):
    offset = 0

    # Decode MEMO SBE header
    block_length = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    template_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    schema_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
    offset += 1

    version = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    # Extract message ID from the encoded message
    message_id = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
    offset += 2

    
    for key,id in schema.items():
        if message_id == id:
           fields = schema[message_id]['fields']
           decoded_fields = {}
        else:
            raise ValueError(f"Message ID '{message_id}' not found in the schema.")



    # Decode the fields of the message
    while offset < len(encoded_message):
        field_id = struct.unpack('B', encoded_message[offset:offset + 1])[0]
        offset += 1

        field_length = struct.unpack('>H', encoded_message[offset:offset + 2])[0]
        offset += 2

        field_value = encoded_message[offset:offset + field_length]
        offset += field_length

        field_type = fields[field_id]
        decoded_value = decode_field(field_type, field_value)

        decoded_fields[field_id] = decoded_value

    return message_name, decoded_fields


if __name__ == '__main__':
    schema_file = 'sbe-schema-equities.xml'
    schema = load_schema(schema_file)

    # Example encoding
    message_name = 'NewOrderSingle'
    field_values = {
        'ClOrdID': '12345',
        'Symbol': 'AAPL',
        'Side': '1',
        'OrderQty': 100,
        'Price': 150.0,
        'OrdType': 2,
        'TimeInForce': 0,
        'OrderCapacity': 'A',
        'CustOrderCapacity': 1,
        'ExecInst': 2
    }

    encoded_message = encode_message(schema, message_name, field_values)
    decoded_message = decode_message(schema, encoded_message)
    print(schema)
    print(decoded_message)
    print(f"Encoded message: {encoded_message}")
    
    
    
    
    
    
    (myenv) pvellanki@qa2434:~/loadgenerator/sbe/equities$ python3 test2.py 
{'NewOrderSingle': {'id': 1, 'fields': {1: 'NewOrderSingleClOrdID', 2: 'NewOrderSingleMPID', 3: 'NewOrderSingleSymbol', 4: 'NewOrderSingleSymbolSfx', 5: 'SideType', 6: 'uint32', 7: 'OrdType', 8: 'PriceType', 9: 'TimeInForceType', 10: 'OrderCapacityType', 11: 'CustOrderCapacityType', 12: 'ExecInstType', 13: 'PriceType', 14: 'PegType', 15: 'UTCTimestampNanos', 16: 'uint32', 17: 'uint32', 18: 'DispMethodType', 19: 'ReserveReplenishTimingType', 20: 'uint32', 21: 'char', 22: 'RepriceFrequencyType', 23: 'RepriceBehaviorType', 24: 'uint16', 25: 'uint16', 26: 'SelfTradePreventionType', 27: 'uint16', 28: 'NewOrderSingleLnkId'}}, 'OrderCancelReplaceRequest': {'id': 2, 'fields': {1: 'OrderCancelReplaceRequestOrigClOrdID', 2: 'OrderCancelReplaceRequestClOrdID', 3: 'OrderCancelReplaceRequestSymbol', 4: 'OrderCancelReplaceRequestSymbolSfx', 5: 'SideType', 6: 'uint32', 7: 'OrdType', 8: 'PriceType', 9: 'uint32', 10: 'char', 11: 'OrderCancelReplaceRequestLnkId'}}, 'OrderCancelRequest': {'id': 3, 'fields': {1: 'OrderCancelRequestOrigClOrdID', 2: 'uint64', 3: 'OrderCancelRequestClOrdID', 4: 'OrderCancelRequestSymbol', 5: 'OrderCancelRequestSymbolSfx'}}, 'MassCancelRequest': {'id': 4, 'fields': {1: 'MassCancelRequestClOrdID', 2: 'MassCancelRequestSymbol', 3: 'MassCancelRequestSymbolSfx', 4: 'SideType', 5: 'PriceType', 6: 'PriceType', 7: 'uint16'}}, 'ExecutionReport_PendingNew': {'id': 5, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_PendingNewClOrdID', 4: 'uint64', 5: 'ExecutionReport_PendingNewMPID', 6: 'OrdStatusType', 7: 'ExecutionReport_PendingNewSymbol', 8: 'ExecutionReport_PendingNewSymbolSfx', 9: 'SideType', 10: 'OrdType', 11: 'uint32', 12: 'PriceType', 13: 'TimeInForceType', 14: 'OrderCapacityType', 15: 'CustOrderCapacityType', 16: 'ExecInstType', 17: 'PriceType', 18: 'PegType', 19: 'UTCTimestampNanos', 20: 'uint32', 21: 'uint32', 22: 'DispMethodType', 23: 'ReserveReplenishTimingType', 24: 'uint32', 25: 'char', 26: 'RepriceFrequencyType', 27: 'RepriceBehaviorType', 28: 'uint16', 29: 'uint16', 30: 'SelfTradePreventionType', 31: 'uint16', 32: 'uint32', 33: 'uint32', 34: 'ExecutionReport_PendingNewLnkId'}}, 'ExecutionReport_New': {'id': 6, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_NewClOrdID', 4: 'uint64', 5: 'ExecutionReport_NewMPID', 6: 'OrdStatusType', 7: 'ExecutionReport_NewSymbol', 8: 'ExecutionReport_NewSymbolSfx', 9: 'SideType', 10: 'OrdType', 11: 'uint32', 12: 'PriceType', 13: 'TimeInForceType', 14: 'OrderCapacityType', 15: 'CustOrderCapacityType', 16: 'ExecInstType', 17: 'PriceType', 18: 'PegType', 19: 'UTCTimestampNanos', 20: 'uint32', 21: 'uint32', 22: 'DispMethodType', 23: 'ReserveReplenishTimingType', 24: 'uint32', 25: 'char', 26: 'RepriceFrequencyType', 27: 'RepriceBehaviorType', 28: 'uint16', 29: 'uint16', 30: 'SelfTradePreventionType', 31: 'uint16', 32: 'uint32', 33: 'uint32', 34: 'UTCTimestampNanos', 35: 'ExecutionReport_NewLnkId'}}, 'ExecutionReport_Rejected': {'id': 7, 'fields': {1: 'UTCTimestampNanos', 2: 'ExecutionReport_RejectedClOrdID', 3: 'uint64', 4: 'OrdStatusType', 5: 'ExecutionReport_RejectedSymbol', 6: 'ExecutionReport_RejectedSymbolSfx', 7: 'uint32', 8: 'uint32', 9: 'OrderRejectReasonCode', 10: 'ExecutionReport_RejectedLnkId'}}, 'ExecutionReport_Trade': {'id': 8, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_TradeClOrdID', 4: 'uint64', 5: 'OrdStatusType', 6: 'uint32', 7: 'PriceType', 8: 'uint32', 9: 'uint32', 10: 'UTCTimestampNanos', 11: 'LastLiquidityIndType', 12: 'ExchangeCode', 13: 'uint64', 14: 'ExecutionReport_TradeLnkId'}}, 'ExecutionReport_PendingCancel': {'id': 9, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_PendingCancelClOrdID', 4: 'ExecutionReport_PendingCancelOrigClOrdID', 5: 'uint64', 6: 'ExecutionReport_PendingCancelSymbol', 7: 'ExecutionReport_PendingCancelSymbolSfx', 8: 'OrdStatusType', 9: 'uint32', 10: 'uint32', 11: 'ExecutionReport_PendingCancelLnkId'}}, 'PendingMassCancel': {'id': 10, 'fields': {1: 'UTCTimestampNanos', 2: 'PendingMassCancelClOrdID', 3: 'PendingMassCancelSymbol', 4: 'PendingMassCancelSymbolSfx', 5: 'SideType', 6: 'PriceType', 7: 'PriceType', 8: 'uint16'}}, 'ExecutionReport_Canceled': {'id': 11, 'fields': {1: 'UTCTimestampNanos', 2: 'ExecutionReport_CanceledClOrdID', 3: 'ExecutionReport_CanceledOrigClOrdID', 4: 'uint64', 5: 'uint64', 6: 'OrdStatusType', 7: 'uint32', 8: 'uint32', 9: 'CancelReasonCode', 10: 'UTCTimestampNanos', 11: 'ExecutionReport_CanceledLnkId'}}, 'MassCancelDone': {'id': 12, 'fields': {1: 'UTCTimestampNanos', 2: 'MassCancelDoneClOrdID'}}, 'ExecutionReport_PendingReplace': {'id': 13, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_PendingReplaceClOrdID', 4: 'ExecutionReport_PendingReplaceOrigClOrdID', 5: 'uint64', 6: 'ExecutionReport_PendingReplaceSymbol', 7: 'ExecutionReport_PendingReplaceSymbolSfx', 8: 'SideType', 9: 'uint32', 10: 'OrdType', 11: 'PriceType', 12: 'uint32', 13: 'char', 14: 'OrdStatusType', 15: 'uint32', 16: 'uint32', 17: 'ExecutionReport_PendingReplaceLnkId'}}, 'ExecutionReport_Replaced': {'id': 14, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_ReplacedClOrdID', 4: 'ExecutionReport_ReplacedOrigClOrdID', 5: 'uint64', 6: 'ExecutionReport_ReplacedSymbol', 7: 'ExecutionReport_ReplacedSymbolSfx', 8: 'SideType', 9: 'uint32', 10: 'OrdType', 11: 'PriceType', 12: 'uint32', 13: 'char', 14: 'OrdStatusType', 15: 'uint32', 16: 'uint32', 17: 'UTCTimestampNanos', 18: 'ExecutionReport_ReplacedLnkId'}}, 'ExecutionReport_TradeCorrection': {'id': 15, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_TradeCorrectionClOrdID', 4: 'uint64', 5: 'uint64', 6: 'uint64', 7: 'OrdStatusType', 8: 'PriceType', 9: 'uint32', 10: 'uint32', 11: 'uint32', 12: 'ExecutionReport_TradeCorrectionLnkId'}}, 'ExecutionReport_TradeBreak': {'id': 16, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_TradeBreakClOrdID', 4: 'uint64', 5: 'uint64', 6: 'uint64', 7: 'OrdStatusType', 8: 'uint32', 9: 'uint32', 10: 'ExecutionReport_TradeBreakLnkId'}}, 'ExecutionReport_Restatement': {'id': 17, 'fields': {1: 'UTCTimestampNanos', 2: 'uint64', 3: 'ExecutionReport_RestatementClOrdID', 4: 'uint64', 5: 'OrdStatusType', 6: 'PriceType', 7: 'uint32', 8: 'uint32', 9: 'uint32', 10: 'ExecRestatementType', 11: 'UTCTimestampNanos', 12: 'ExtendedRestatementReasonType', 13: 'ExecutionReport_RestatementLnkId'}}, 'OrderCancelReject': {'id': 18, 'fields': {1: 'UTCTimestampNanos', 2: 'OrderCancelRejectClOrdID', 3: 'CxlRejResponseToType', 4: 'CancelRejectReasonCode', 5: 'OrderCancelRejectLnkId'}}, 'MassCancelReject': {'id': 20, 'fields': {1: 'UTCTimestampNanos', 2: 'MassCancelRejectClOrdID', 3: 'MassCancelRejectSymbol', 4: 'MassCancelRejectSymbolSfx', 5: 'SideType', 6: 'PriceType', 7: 'PriceType', 8: 'uint16', 9: 'MassCancelRejectReasonCode'}}}
Traceback (most recent call last):
  File "/home/pvellanki/loadgenerator/sbe/equities/test2.py", line 277, in <module>
    decoded_message = decode_message(schema, encoded_message)
  File "/home/pvellanki/loadgenerator/sbe/equities/test2.py", line 234, in decode_message
    raise ValueError(f"Message ID '{message_id}' not found in the schema.")
ValueError: Message ID '1' not found in the schema.
