import configparser
import random
import time
import quickfix as fix

# Global variables
sessions = {}

# Class representing the FIX application
class MyApplication(fix.Application):
    def __init__(self, template_file, message_weights, message_rate):
        super().__init__()
        self.template_file = template_file
        self.message_weights = message_weights
        self.message_rate = message_rate
        self.session_id = None

    def onCreate(self, sessionID):
        print("Session created -", sessionID.toString())
        self.session_id = sessionID

    def toAdmin(self,message, sessionID):
        print("sent admin message", message.toString())

    def fromAdmin(self, message, sessionID):
        global sessions
        session_id = sessionID.toString()
        incoming_msg_seq_num = int(message.getHeader().getField(34))
        msg_type = message.getHeader().getField(35)

        if msg_type == 'A':  # Logon message
            if incoming_msg_seq_num == 1:
                print(f"Session established for {session_id}")
                sessions[session_id] = True
        elif msg_type == '5':  # Logout message
            print(f"Session disconnected for {session_id}")
            sessions[session_id] = False

    def onLogout(self, sessionID):
        print("Logout initiated -", sessionID.toString())

    def generate_clordid(self):
        return str(random.randint(100000, 999999))

    def generate_message(self, template):
        # Replace placeholders in the message template
        message = template.replace('<ClOrdID>', generate_clordid())
        message = message.replace('<SeqNum>', str(get_outgoing_seq_num(self.session_id)))
        message = message.replace('<SendingTime>', fix.UtcTimeStamp().getString())

        # Calculate the CheckSum
        checksum = calculate_checksum(message)

        # Calculate the message length (excluding SOH characters)
        message_length = len(message) - message.count('|')

        # Replace the placeholders for message length and CheckSum
        message = message.replace('<BodyLength>', str(message_length))
        message = message.replace('<CheckSum>', checksum)

        return message

        # Function to calculate the CheckSum (Tag 10) for a given FIX message
    def calculate_checksum(self,message):
        checksum = sum(ord(c) for c in message) % 256
        return f'{checksum:03}'  # Ensure the CheckSum is three digits

        # Function to get the outgoing sequence number for a session
    def get_outgoing_seq_num(self,session_id):
        session = fix.Session.lookupSession(fix.SessionID(session_id))
        if session is not None:
            return session.getNextSenderMsgSeqNum()

        # Function to increment the outgoing sequence number for a session
    def increment_outgoing_seq_num(self,session_id):
        session = fix.Session.lookupSession(fix.SessionID(session_id))
        if session is not None:
            session.incrementNextSenderMsgSeqNum()

        # Function to send heartbeat messages at a specified interval
    def send_heartbeats(self,session_id, interval):
        while sessions[session_id]:
            session = fix.Session.lookupSession(fix.SessionID(session_id))
            if session is not None:
                heartbeat_message = fix.Message()
                heartbeat_message.getHeader().setField(34, str(get_outgoing_seq_num(session_id)))
                fix.Session.sendToTarget(heartbeat_message, session_id)
                increment_outgoing_seq_num(session_id)
        time.sleep(interval)

    def generate_load(self):
        # Read the template file and extract message templates
        with open(self.template_file, 'r') as file:
             templates = file.readlines()

        # Generate messages based on weights
        load = []
        for template in templates:
            message_type = self.get_message_type(template)
            if message_type and message_type in self.message_weights:
               weight = int(self.message_weights[message_type])
               load.extend([template.strip()] * weight)

        random.shuffle(load)
        load_length = len(load)
        print(load_length)
        iterations = int(self.message_rate * send_duration)

        # Repeat load if necessary to achieve desired send duration
        if iterations > load_length:
           quotient, remainder = divmod(iterations, load_length)
           print("Iterations",iterations)
           load = load * quotient + load[:remainder]
        else:
           load = load[:iterations]

        return load

    def get_message_type(self, template):
        fields = template.split('|')
        for field in fields:
            if field.startswith('35='):
                return field.split('=')[1]
        return ''

    def run(self):
        # Initialize FIX settings
        settings = fix.SessionSettings(self.connection_config_file)

        # Initialize FIX application
        application = fix.SocketInitiator(self, fix.FileStoreFactory(settings), settings)

        # Start the FIX sessions
        application.start()

        # Wait for sessions to be established
        while not all(sessions.values()):
            time.sleep(1)

        # Generate and send messages
        load = self.generate_load()

        start_time = time.time()
        message_count = 0

        while True:
            elapsed_time = time.time() - start_time

            if elapsed_time >= self.message_rate:
                break

            if message_count >= len(load):
                message_count = 0

            message = fix.Message(self.generate_message(load[message_count]))
            fix.Session.sendToTarget(message, self.session_id)

            message_count += 1

            time.sleep(1)

        # Stop the FIX sessions
        application.stop()

# Read configuration from config.ini
config = configparser.ConfigParser()
config.read('config.ini')

# Load configuration values
template_file = config.get('LoadGenerator', 'template_file')
connection_config_file = config.get('LoadGenerator', 'connection_config_file')
log_file = config.get('LoadGenerator', 'log_file')
message_rate = float(config.get('LoadGenerator', 'message_rate'))
send_duration = int(config.get('LoadGenerator', 'send_duration'))

message_weights = dict(config.items('MessageTypes'))

# Initialize the FIX application
app = MyApplication(template_file, message_weights, message_rate)
app.connection_config_file = connection_config_file
app.send_duration = send_duration

# Run the FIX application
app.run()




import datetime

def generate_message(self, template):
    # Replace placeholders in the message template
    message = template.replace('<ClOrdID>', self.generate_clordid())
    message = message.replace('<SeqNum>', str(self.get_outgoing_seq_num(self.session_id.toString())))

    # Generate the SendingTime in the desired format
    sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
    message = message.replace('<SendingTime>', sending_time)

    # Calculate the CheckSum
    checksum = self.calculate_checksum(message)

    # Calculate the message length (excluding SOH characters)
    message_length = len(message) - message.count('|')

    # Replace the placeholders for message length and CheckSum
    message = message.replace('<BodyLength>', str(message_length))
    message = message.replace('<CheckSum>', checksum)

    # Ensure proper field termination
    message = message.replace('|', '\x01')  # Replace '|' with SOH character

    return message
    
    
    
def generate_message(self, template):
    # Replace placeholders in the message template
    message = template.replace('<ClOrdID>', self.generate_clordid())
    message = message.replace('<SeqNum>', str(self.get_outgoing_seq_num(self.session_id.toString())))

    # Generate the SendingTime in the desired format
    sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
    message = message.replace('<SendingTime>', sending_time)

    # Calculate the CheckSum
    checksum = self.calculate_checksum(message)

    # Calculate the message length (excluding SOH characters)
    message_length = len(message) - message.count('\x01')  # Exclude the BodyLength field itself

    # Replace the placeholders for message length and CheckSum
    message = message.replace('<BodyLength>', str(message_length))
    message = message.replace('<CheckSum>', checksum)

    return message
    
    
    
    def generate_message(self, template):
    # Replace placeholders in the message template
    message = template.replace('<ClOrdID>', self.generate_clordid())
    message = message.replace('<SeqNum>', str(self.get_outgoing_seq_num(self.session_id.toString())))

    # Generate the SendingTime in the desired format
    sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
    message = message.replace('<SendingTime>', sending_time)

    # Calculate the CheckSum
    checksum = self.calculate_checksum(message)

    # Calculate the message length (excluding SOH characters)
    message_length = len(message) - message.count('|')

    # Replace the placeholders for message length and CheckSum
    message = message.replace('<BodyLength>', str(message_length))
    message = message.replace('<CheckSum>', checksum)

    # Ensure proper field termination
    message = message.replace('|', '\x01')  # Replace '|' with SOH character

    return message


   65     def generate_message(self, template):
     66         # Replace placeholders in the message template
     67         message = template.replace('<ClOrdID>', self.generate_clordid())
     68 
     69         # Get the outgoing sequence number
     70         seq_num = str(self.get_outgoing_seq_num(self.session_id))
     71         print(seq_num)
     72 
     73         # Replace the <SeqNum> placeholder with the sequence number
     74         message = message.replace('<MsgSeqNum>', seq_num)
     75 
     76         # Generate the SendingTime in the desired format
     77         sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
     78         message = message.replace('<SendingTime>', sending_time)
     79       
     80         # Replace the field delimiter from '|' to SOH character
     81         message = message.replace('|', chr(0x01))
     82 
     83         # Calculate the CheckSum
     84         checksum = self.calculate_checksum(message)
     85 
     86         # Calculate the message length (excluding SOH characters)
     87         message_length = len(message) - message.count(chr(0x01))
     88 
     89         # Replace the placeholders for message length and CheckSum
     90         message = message.replace('<BodyLength>', str(message_length))
     91         message = message.replace('<CheckSum>', checksum)
     92         print(message)
     93 
     94         return message
    
def get_outgoing_seq_num(self, session_id):
    session = fix.Session.lookupSession(session_id)
    if session is not None:
        session_id = session.getSessionID()
        return session_id.getSenderSeqNum()
    return 0
    
    
    
    # Calculate the message length (excluding SOH characters)
    body_start_index = message.index('9=')
    body_end_index = message.index('10=')
    body_length = body_end_index - body_start_index





