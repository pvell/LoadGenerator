import random
import time
import datetime
import os
import quickfix as fix
import quickfix44 as fix44
import configparser

# Global variables
sessions = {}

class MyApplication(fix.Application):
    def __init__(self, message_weights, message_rate):
        super().__init__()
        self.message_weights = message_weights
        self.message_rate = message_rate
        self.sessions = {}
        self.log_directory = "log"
        self.captured_clordids = []
        self.captured_clordid_side_mapping = {}

    def onCreate(self, sessionID):
        print("Session created -", sessionID.toString())
        self.sessions[sessionID] = fix.Session.lookupSession(sessionID)

    def toAdmin(self, message, sessionID):
        if message.getHeader().getField(fix.MsgType()).getString() == fix.MsgType_Logon:
            message.getHeader().setField(1408, "1.3")
            message.getHeader().setField(43, "Y")
            print("sent admin message", message.toString())
        return True

    def toApp(self, message, sessionID):
        session_id = sessionID.toString()
        with open(self.get_log_file(), "a") as file:
            file.write(f"Session: {session_id}\n")
            file.write(message.toString() + '\n')
        print("sent application message", message.toString())

    def fromApp(self, message, sessionID):
        session_id = sessionID.toString()
        with open(self.get_log_file(), "a") as file:
            file.write(f"Session: {session_id}\n")
            file.write(message.toString() + '\n')
        print("received application message", message.toString())
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_type = fix.ExecType()
            side = fix.Side()
            tag_21035 = fix.StringField(21035)
            message.getField(cl_ord_id)
            message.getField(exec_type)
            message.getField(side)
            message.getField(tag_21035)
           
            if exec_type.getValue() == fix.ExecType_NEW or exec_type.getValue() == fix.ExecType_TRADE:
                clordid = cl_ord_id.getString()
                side_value = side.getString()
                tag_21035_value = tag_21035.getValue()

                self.captured_clordids.append(clordid)
                self.captured_clordid_side_mapping[clordid] = {"side": side_value, "tag_21035": tag_21035_value, "session": sessionID.toString()}

    def fromAdmin(self, message, sessionID):
        session_id = sessionID.toString()
        incoming_msg_seq_num = int(message.getHeader().getField(34))
        msg_type = message.getHeader().getField(35)

        if msg_type == 'A':
            if incoming_msg_seq_num == 1:
                print(f"Session established for {session_id}")
                sessions[session_id] = True
        elif msg_type == '5':
            print(f"Session disconnected for {session_id}")
            sessions[session_id] = False
        with open(self.get_log_file(), 'a') as file:
            file.write(f"Received fromAdmin message:{message.toString()}\n")

    def onLogout(self, sessionID):
        print("Logout initiated -", sessionID.toString())

    def onLogon(self, sessionID):
        print("Logon Successful -", sessionID.toString())

    def generate_message(self, message_type, session_id):
        if message_type.lower() == "logon":
            message = fix.Message()
            message.getHeader().setField(fix.BeginString(fix.BeginString_FIXT11))
            message.getHeader().setField(fix.MsgType(fix.MsgType_Logon))
            message.setField(fix.EncryptMethod(0))
            message.setField(fix.HeartBtInt(30))
            message.setField(fix.ResetSeqNumFlag(False))
            message.setField(fix.DefaultApplVerID("FIX.5.0SP2"))
            message.setField(fix.DefaultCstmApplVerID("1.3"))
            
        elif message_type.lower() == "newordersingle":

                selected_symbol = random.choice(symbols)
                random_quantity = random.randint(1, 100)
                random_price = round(random.uniform(1, 100), 0)
                efid_mapping = dict(config.items("EFID"))

                sender_comp_id = session_id.getSenderCompID().getString()

                if sender_comp_id.lower() in efid_mapping:
                    efid = efid_mapping[sender_comp_id.lower()]
                else:
                    print(f"EFID mapping not found for SenderCompID: {sender_comp_id}")
                
                message = fix.Message()
                message.getHeader().setField(fix.BeginString(session_id.getBeginString().getString()))
                message.getHeader().setField(fix.MsgType(fix.MsgType_NewOrderSingle))
                message.getHeader().setField(fix.SenderCompID(session_id.getSenderCompID().getString()))
                message.getHeader().setField(fix.TargetCompID(session_id.getTargetCompID().getString()))
                message.getHeader().setField(fix.MsgSeqNum(self.get_outgoing_seq_num(session_id)))


                # Set other required fields for NewOrderSingle message
                #message.setField(fix.Symbol(selected_symbol))
                message.setField(fix.Side(fix.Side_BUY))
                message.setField(fix.OrderQty(random_quantity))
                message.setField(fix.Price(random_price))
                message.setField(fix.OrdType(fix.OrdType_LIMIT))
                message.setField(fix.TimeInForce(fix.TimeInForce_DAY))
                message.setField(fix.ClOrdID(self.generate_clordid()))
                message.setField(fix.ExecInst("h"))
                message.setField(1815,"6")
                message.setField(21035,selected_symbol)
                sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
                message.setField(60,sending_time)
                message.setField(77,"O")
                #message.setField(201,"1")
                #message.setField(202,"100")
                #message.setField(541,"20230915")


                # Create the repeating group for PartyIDs
                party_group = fix44.NewOrderSingle.NoPartyIDs()
                party_group.setField(448, efid)
                party_group.setField(447, "D")
                party_group.setField(452, "1")
                message.addGroup(party_group)
                



        elif message_type.lower() == "orderreplace":
            pass
            # ...
            # Code for other message types
            # ...

        elif message_type.lower() == "ordercancel":
            if self.captured_clordids:
                clordid = random.choice(self.captured_clordids)
                clordid_info = self.captured_clordid_side_mapping.get(clordid)
                if clordid_info is not None:
                    session_id_str = clordid_info.get("session")
                    clordid_session = self.sessions.get(session_id_str)

                    if clordid_session is not None:
                        side = clordid_info["side"]
                        tag_21035 = clordid_info["tag_21035"]
                        message = fix.Message()
                        sending_time = datetime.datetime.utcnow().strftime('%Y%m%d-%H:%M:%S.%f')[:-3]
                        message.setField(60, sending_time)
                        message.getHeader().setField(fix.BeginString(session_id.getBeginString().getString()))
                        message.getHeader().setField(fix.MsgType(fix.MsgType_OrderCancelRequest))
                        message.getHeader().setField(fix.SenderCompID(session_id.getSenderCompID().getString()))
                        message.getHeader().setField(fix.TargetCompID(session_id.getTargetCompID().getString()))
                        message.getHeader().setField(fix.MsgSeqNum(self.get_outgoing_seq_num(session_id)))
                        message.setField(fix.ClOrdID(self.generate_clordid()))
                        message.setField(fix.OrigClOrdID(clordid))
                        message.setField(fix.Side(side))
                        message.setField(21035, tag_21035)
                        
                        fix.Session.sendToTarget(message, clordid_session)
                    else:
                        print(f"Error: ClOrdID info not found for ClOrdID={clordid}")
                        return fix.Message()

                else:
                    print(f"Error: ClOrdID info not found for ClOrdID={clordid}")
                    return fix.Message()

            else:
                print("No captured ClOrdIDs available for order cancel")
                return fix.Message()

            return message

        else:
            return None

    def generate_load(self):
        load = []
        for message_type, weight in self.message_weights.items():
            weight = int(weight)
            print(weight)
            template = self.generate_template_for_message_type(message_type)
            if template:
                load.extend([message_type.lower()] * weight)

        print(f"Generated load: {load}")
        random.shuffle(load)
        load_length = len(load)
        iterations = int(self.message_rate * self.send_duration)

        if iterations > load_length:
            quotient, remainder = divmod(iterations, load_length)
            print(f"Repeating load: {quotient} times, with remainder: {remainder}")
            load = load * quotient + load[:remainder]
        else:
            load = load[:iterations]

        return load

    def generate_template_for_message_type(self, message_type):
        if message_type.lower() == "logon":
            return "logon"
        elif message_type.lower() == "newordersingle":
            return "new_order_template"
        elif message_type.lower() == "orderreplace":
            return "order_replace_template"
        elif message_type.lower() == "ordercancel":
            return "order_cancel_template"
        else:
            return None
        
    def get_log_file(self):
        os.makedirs(self.log_directory, exist_ok=True)
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H")
        log_file_name = f"log_file_{timestamp}.log"
        print(os.path.join(self.log_directory, log_file_name))
        return os.path.join(self.log_directory, log_file_name)

# Read configuration from config.ini
config = configparser.ConfigParser()
config.read("config.ini")

# Load configuration values
connection_config_file = config.get("LoadGenerator", "connection_config_file")
message_rate = float(config.get("LoadGenerator", "message_rate"))
send_duration = int(config.get("LoadGenerator", "send_duration"))
message_weights = dict(config.items("MessageTypes"))

# Initialize the FIX application
app = MyApplication(message_weights, message_rate)
app.connection_config_file = connection_config_file
app.send_duration = send_duration

# Run the FIX application
app.run()
