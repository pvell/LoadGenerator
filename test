import unittest
import time
import random
import configparser
import quickfix as fix
import json

# Global variables
sessions = {}

config = configparser.ConfigParser()
config.read("config.cfg")
log_file = config.get("DEFAULT", "FileLogPath")

def replace_placeholders(template, placeholders):
    for placeholder, value in placeholders.items():
        template = template.replace(placeholder, value)
    return template

def validate_execution_report(exec_report, order_qty, symbol, order_type, tif):
    # Validate OrderQty
    assert exec_report.getField(32) == str(order_qty), "Execution Report OrderQty mismatch"

    # Validate Symbol
    assert exec_report.getField(55) == symbol, "Execution Report Symbol mismatch"

    # Validate OrdType
    assert exec_report.getField(40) == order_type, "Execution Report OrdType mismatch"

    # Validate TimeInForce
    assert exec_report.getField(59) == tif, "Execution Report TimeInForce mismatch"

class MyApplication(fix.Application):
    def __init__(self):
        super().__init__()
        self.execution_report_received = False
        self.last_execution_report = None
        self.cl_ord_ids = []
        self.sessions = {}
        self.log_file = log_file

    def onCreate(self, sessionID):
        print("Session created -", sessionID.toString())
        self.sessions[sessionID] = fix.Session.lookupSession(sessionID)
        

    def onLogon(self, sessionID):
        print("Logon Successful -", sessionID.toString())

    def onLogout(self, sessionID):
        print("Logout initiated -", sessionID.toString())

    def toAdmin(self, message, sessionID):
        if message.getHeader().getField(fix.MsgType()).getString() == fix.MsgType_Logon:
            message.getHeader().setField(1408, "1.3")
            print("sent admin message", message.toString())

    def fromAdmin(self, message, sessionID):
        global sessions
        session_id = sessionID.toString()
        incoming_msg_seq_num = int(message.getHeader().getField(34))
        msg_type = message.getHeader().getField(35)
        print(message)

        if msg_type == 'A':  # Logon message
            if incoming_msg_seq_num == 1:
                print(f"Session established for {session_id}")
                sessions[session_id] = True
        elif msg_type == '5':  # Logout message
            print(f"Session disconnected for {session_id}")
            sessions[session_id] = False
        with open(self.log_file, 'a') as file:
            file.write(f"Received fromAdmin message:{message.toString()}\n")

    def toApp(self, message, sessionID):
        session_id = sessionID.toString()
        with open(self.log_file, "a") as file:
                file.write(f"Session: {session_id}\n")
                file.write(message.toString() + '\n')
        print("sent application message", message.toString())

    def fromApp(self, message, sessionID):
        msg_type = fix.MsgType()
        message.getHeader().getField(msg_type)

        if msg_type.getValue() == fix.MsgType_ExecutionReport:
            cl_ord_id = fix.ClOrdID()
            exec_report = fix.ExecutionReport()
            message.getField(cl_ord_id)
            message.getField(exec_report)
            self.last_execution_report = exec_report

            # Check if the execution report matches the conditions
            if exec_report.getField(39).getString() == '0' or exec_report.getField(39).getString() == '150':
                self.execution_report_received = True

    def generate_clordid(self):
        return str(random.randint(100000, 999999))

class TestFIXSession(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        cls.app = MyApplication()
        cls.settings = fix.SessionSettings("config.cfg")
        cls.storeFactory = fix.FileStoreFactory(cls.settings)
        cls.logFactory = fix.ScreenLogFactory(cls.settings)
        cls.initiator = fix.SocketInitiator(cls.app, cls.storeFactory, cls.settings, cls.logFactory)
        cls.initiator.start()
        time.sleep(1)

    @classmethod
    def tearDownClass(cls):
        cls.initiator.stop()

    def send_new_order_single(self, order_type, time_in_force, order_qty, symbol, exec_inst=''):
        # Read the JSON file
        with open('instrument_definitions.json', 'r') as file:
            json_data = json.load(file)

        # Find the matching optionId based on the symbol
        option_id = None
        for item in json_data:
            if item['underlyingSymbolId'] == symbol:
                option_id = item['optionId']
                break

        if not option_id:
            raise ValueError(f"No optionId found for symbol: {symbol}")

        message = fix.Message()
        message.getHeader().setField(fix.BeginString(self.app.sessions[self.session_id].getBeginString().getString()))
        message.getHeader().setField(fix.MsgType(fix.MsgType_NewOrderSingle))
        message.getHeader().setField(fix.SenderCompID(self.app.sessions[self.session_id].getSenderCompID().getString()))
        message.getHeader().setField(fix.TargetCompID(self.app.sessions[self.session_id].getTargetCompID().getString()))
        message.getHeader().setField(fix.MsgSeqNum(self.app.get_outgoing_seq_num(self.session_id)))

        # Set other required fields for NewOrderSingle message
        message.setField(fix.Symbol(symbol))
        message.setField(fix.Side(fix.Side_BUY))
        message.setField(fix.OrderQty(order_qty))
        message.setField(fix.Price(8))
        message.setField(fix.OrdType(fix.OrdType_LIMIT))
        message.setField(fix.TimeInForce(time_in_force))
        message.setField(fix.ClOrdID(self.app.generate_clordid()))
        message.setField(fix.ExecInst(exec_inst))
        message.setField(1815, "6")
        message.setField(21035, option_id)
        message.setField(201, json_data[0]['putCall'])
        message.setField(202, str(json_data[0]['strikePrice']))
        message.setField(541, str(json_data[0]['expirationDate']))

        # Create the repeating group for PartyIDs
        party_group = fix.Group(fix.Tag_NoPartyIDs, fix.Tag_PartyID, [fix.Tag_PartyIDSource, fix.Tag_PartyRole])
        party_group.setField(fix.PartyID("QAX3"))
        party_group.setField(fix.PartyIDSource("D"))
        party_group.setField(fix.PartyRole("1"))
        message.addGroup(party_group)

        fix.Session.sendToTarget(message, self.session_id)

        time.sleep(2)

        self.assertTrue(self.app.execution_report_received)
        exec_report = self.app.last_execution_report
        cl_ord_id = exec_report.getField(11)

        validate_execution_report(exec_report, order_qty=order_qty, symbol=symbol, order_type=order_type, tif=time_in_force)
        self.assertEqual(exec_report.getField(39), '0')

    def send_cancel_replace_request(self, orig_cl_ord_id, new_price=None, new_order_qty=None):
        # Implementation for sending cancel/replace request
        pass

    def send_order_cancel_request(self, orig_cl_ord_id):
        # Implementation for sending order cancel request
        pass

    def test_market_order_with_day_tif(self):
        self.send_new_order_single(order_type='1', time_in_force='0', order_qty=100, symbol='AAPL')

    def test_market_order_with_ioc_tif(self):
        self.send_new_order_single(order_type='1', time_in_force='3', order_qty=100, symbol='AAPL')

    def test_limit_order_with_day_tif(self):
        self.send_new_order_single(order_type='2', time_in_force='0', order_qty=100, symbol='AAPL')

    def test_limit_order_with_ioc_tif(self):
        self.send_new_order_single(order_type='2', time_in_force='3', order_qty=100, symbol='AAPL')

    def test_limit_order_with_iso_modifier(self):
        self.send_new_order_single(order_type='2', time_in_force='0', order_qty=100, symbol='AAPL', exec_inst='F')

    def test_rejected_market_order_with_iso_modifier(self):
        self.send_new_order_single(order_type='1', time_in_force='0', order_qty=100, symbol='AAPL', exec_inst='F')
        self.assertEqual(self.app.last_execution_report.getField(39), '8')

    def test_cancel_replace_price(self):
        self.send_new_order_single(order_type='2', time_in_force='0', order_qty=100, symbol='AAPL')
        orig_cl_ord_id = self.app.last_execution_report.getField(11)
        self.send_cancel_replace_request(orig_cl_ord_id, new_price=150)

    def test_cancel_replace_qty(self):
        self.send_new_order_single(order_type='2', time_in_force='0', order_qty=100, symbol='AAPL')
        orig_cl_ord_id = self.app.last_execution_report.getField(11)
        self.send_cancel_replace_request(orig_cl_ord_id, new_order_qty=50)

    def tearDown(self):
        orig_cl_ord_id = self.app.last_execution_report.getField(11)
        self.send_order_cancel_request(orig_cl_ord_id)

if __name__ == '__main__':
    unittest.main()











class PartyIDSource:
    SIZE = 1

    def __init__(self, value):
        self.value = value

    def encode(self):
        return self.value.encode()

    def decode(self, buffer):
        self.value = buffer.decode()


class PartyRoleType:
    SIZE = 1

    def __init__(self, value):
        self.value = value

    def encode(self):
        return pack('>B', self.value)

    def decode(self, buffer):
        self.value = unpack_from('>B', buffer)[0]


class PartiesGroup:
    def __init__(self, party_ids=None):
        self.party_ids = party_ids or []
        print(party_ids)
     

    def encode(self):
        encoded_parties = b''.join(b''.join(party_obj.encode() for party_obj in nested_list) for nested_list in self.party_ids)
        return encoded_parties

    def decode(self, buffer):
        num_party_ids = len(buffer) // (PartyID.SIZE + PartyIDSource.SIZE + PartyRoleType.SIZE)
        self.party_ids = []
        for i in range(num_party_ids):
            offset = i * (PartyID.SIZE + PartyIDSource.SIZE + PartyRoleType.SIZE)
            party_id = PartyID('')
            party_id.decode(buffer[offset:offset + PartyID.SIZE])
            offset += PartyID.SIZE
            party_id_source = PartyIDSource('')
            party_id_source.decode(buffer[offset:offset + PartyIDSource.SIZE])
            offset += PartyIDSource.SIZE
            party_role = PartyRoleType('')
            party_role.decode(buffer[offset:offset + PartyRoleType.SIZE])
            self.party_ids.append([party_id, party_id_source, party_role])





class RepeatingGroupDimensions:
    SIZE = 2

    def __init__(self, block_length,num_groups):
        self.block_length = block_length
        self.num_groups = num_groups

    def encode(self):
        return pack('>BB', self.block_length, self.num_groups)

    def decode(self, buffer):
        self.block_length,self.num_groups = unpack_from('>BB', buffer)



def encode(self):
    encoded_parties = b''.join(party_obj.encode() for nested_list in self.party_ids for party_obj in nested_list)
    return encoded_parties


Traceback (most recent call last):
  File "sbe_load_generator.py", line 470, in <module>
    main()
  File "sbe_load_generator.py", line 451, in main
    message = generate_message(message_type,session_name)
  File "sbe_load_generator.py", line 191, in generate_message
    encoded_message = new_order_single.encode()
  File "/home/pvellanki/myworkspace/SBE/sbe_encoder_decoder.py", line 534, in encode
    encoded_RepeatingGroupDimensions +
TypeError: can't concat builtin_function_or_method to bytes
[pvellanki@sys0412 SBE]$ 




Side	Sub ID	RptID	Ultimate Clearing Firm	Entering Clearing Frim/Contra Clearing Firm	Executing Broker/Position Account Type	Quantity
1	C	240150750		255		141
2	C	240150750		226		141
1	C	240150751		255		76
2	C	240150751		273		76


pvellanki@pvellanki-MacBookPro orsa % python3 gen_orsa_report_v3.py 
Traceback (most recent call last):
  File "/Users/pvellanki/orsa/gen_orsa_report_v3.py", line 131, in <module>
    df.to_excel(writer, sheet_name=f'Chunk_{chunk_num}', index=False)
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/pandas/io/excel/_base.py", line 1322, in __exit__
    self.close()
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/pandas/io/excel/_base.py", line 1326, in close
    self._save()
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/pandas/io/excel/_openpyxl.py", line 109, in _save
    self.book.save(self._handles.handle)
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/workbook/workbook.py", line 386, in save
    save_workbook(self, filename)
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/writer/excel.py", line 294, in save_workbook
    writer.save()
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/writer/excel.py", line 275, in save
    self.write_data()
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/writer/excel.py", line 89, in write_data
    archive.writestr(ARC_WORKBOOK, writer.write())
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/workbook/_writer.py", line 150, in write
    self.write_views()
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/workbook/_writer.py", line 137, in write_views
    active = get_active_sheet(self.wb)
  File "/Users/pvellanki/Library/Python/3.9/lib/python/site-packages/openpyxl/workbook/_writer.py", line 35, in get_active_sheet
    raise IndexError("At least one sheet must be visible")
IndexError: At least one sheet must be visible



class PartiesGroup:
    # ... other methods ...

    def encode(self):
        encoded_parties = b''
        for party in self.party_ids:
            for party_obj in party:
                encoded_parties += party_obj.encode()
        return encoded_parties



pvellanki@qa2434:~/Final/SBE$ pwd
/home/pvellanki/Final/SBE


import xml.etree.ElementTree as ET
import os

# Function to split the XML tree into chunks
def split_xml_tree(xml_tree, chunk_size):
    root = xml_tree.getroot()
    total_elements = len(root)
    chunk_elements = total_elements // chunk_size
    remaining_elements = total_elements % chunk_size

    chunks = []
    start = 0
    for i in range(chunk_size):
        chunk_length = chunk_elements + (1 if i < remaining_elements else 0)
        chunk = ET.ElementTree(ET.Element('Root'))
        chunk.getroot().extend(root[start:start + chunk_length])
        chunks.append(chunk)
        start += chunk_length

    return chunks

# Read the original XML data from trade.xml and parse it into an ElementTree (replace 'trade.xml' with the actual file path)
tree_trade = ET.parse('trade_bak.xml')

# Split the XML tree into 4 chunks
chunked_trees = split_xml_tree(tree_trade, chunk_size=4)

# Create a directory to store the split XML files
output_directory = 'split_xml'
if not os.path.exists(output_directory):
    os.makedirs(output_directory)

# Save each chunk as a separate XML file
for i, chunk_tree in enumerate(chunked_trees):
    output_file_name = os.path.join(output_directory, f'part_{i+1}.xml')
    chunk_tree.write(output_file_name)

print("XML file has been split into 4 parts.")

