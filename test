import socket
import struct
import time
import sbe

# Load the SBE schema
schema_file = 'sbe-schema.xml'
schema = sbe.load_schema(schema_file)

# TCP/IP connection details
host = '10.2.128.10'
port = 30076

# Token and header details
user = 'exactpro6'
password = 'expro6pwd'
token = f'{user}:{password}'

# Login request
message_type = 100
token_type = 'P'  # Assuming token type is always 'P'
token_length = len(token)
header = struct.pack('!BHB', message_type, token_length + 1, token_type.encode('utf-8')[0])
message = header + token.encode('utf-8')

# Create a socket and establish the connection
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((host, port))

# Set socket to binary mode
client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

# Send the login request
client_socket.sendall(message)

# Define a helper function to decode and print SBE messages
def decode_and_print_message(encoded_message):
    message_header = encoded_message[:2]
    message_type, message_length = struct.unpack('!BB', message_header)
    message_body = encoded_message[2:]
    message_name = schema.get_message_name(message_type)
    decoded_message = sbe.decode_message(schema, message_name, message_body)
    print(f"{message_name} Response:")
    print(decoded_message)
    print()

# Wait for the Login Accepted message
response_header = client_socket.recv(2)
response_type, response_length = struct.unpack('!BB', response_header)

if response_type == 1:  # Login Accepted
    response_message = client_socket.recv(response_length)
    print("Login Accepted:")
    decode_and_print_message(response_message)
elif response_type == 2:  # Login Rejected
    response_message = client_socket.recv(response_length)
    print("Login Rejected:")
    decode_and_print_message(response_message)
    client_socket.close()
    exit()  # Exit the script gracefully after login rejection
elif response_type == 3:  # Start of Session
    response_message = client_socket.recv(response_length)
    session_id = struct.unpack('!Q', response_message[:8])[0]
    print("Start of Session. Session ID:", session_id)
else:
    print("Invalid response received.")
    client_socket.close()
    exit()  # Exit the script if an invalid response is received

# Send the MassCancelRequest message
mass_cancel_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    11: "CLORD12345",  # ClOrdID
    54: "BUY",  # Side
    38: 100,  # OrderQty
    44: 99.99,  # Price
    40: "LIMIT",  # OrdType
    59: "DAY",  # TimeInForce
}
mass_cancel_message_name = 'MassCancelRequest'
encoded_mass_cancel_message = sbe.encode_message(schema, mass_cancel_message_name, mass_cancel_fields)
client_socket.send(encoded_mass_cancel_message)

# Handle the response for the MassCancelRequest message
response_header = client_socket.recv(2)
response_type, response_length = struct.unpack('!BB', response_header)

if response_type == 4:  # ExecutionReport
    response_message = client_socket.recv(response_length)
    decode_and_print_message(response_message)
else:
    print("Invalid response received for MassCancelRequest.")

# Send the NewOrderMessage
new_order_fields = {
    52: int(time.time() * 10**9),  # SendingTime: Current timestamp in nanoseconds
    11: "CLORD67890",  # ClOrdID
    54: "SELL",  # Side
    38: 50,  # OrderQty
    44: 101.5,  # Price
    40: "LIMIT",  # OrdType
    59: "DAY",  # TimeInForce
}
new_order_message_name = 'NewOrderMessage'
encoded_new_order_message = sbe.encode_message(schema, new_order_message_name, new_order_fields)
client_socket.send(encoded_new_order_message)

# Handle the response for the NewOrderMessage
response_header = client_socket.recv(2)
response_type, response_length = struct.unpack('!BB', response_header)

if response_type == 4:  # ExecutionReport
    response_message = client_socket.recv(response_length)
    decode_and_print_message(response_message)
else:
    print("Invalid response received for NewOrderMessage.")

# Close the client socket
client_socket.close()
